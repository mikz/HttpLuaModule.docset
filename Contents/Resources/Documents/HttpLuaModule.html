<html lang="en" dir="ltr"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/">
	  <title>HttpLuaModule</title>

    	<link rel="stylesheet" type="text/css" href="skins/bluwiki_skin/main.css" media="screen">
		<link rel="stylesheet" type="text/css" href="skins/bluwiki_skin/clean.css" media="print">

   <style type="text/css">/*<![CDATA[*/
.source-nginx {line-height: normal;}
.source-nginx li, .source-nginx pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for nginx
 * CSS class: source-nginx, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.nginx.source-nginx .de1, .nginx.source-nginx .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.nginx.source-nginx  {font-family:monospace;}
.nginx.source-nginx .imp {font-weight: bold; color: red;}
.nginx.source-nginx li, .nginx.source-nginx .li1 {font-weight: normal; vertical-align:top;}
.nginx.source-nginx .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.nginx.source-nginx .li2 {font-weight: bold; vertical-align:top;}
.nginx.source-nginx .kw1 {color: #b1b100;}
.nginx.source-nginx .kw2 {color: #000000; font-weight: bold;}
.nginx.source-nginx .kw3 {color: #000066;}
.nginx.source-nginx .kw4 {color: #993333;}
.nginx.source-nginx .co1 {color: #808080; font-style: italic;}
.nginx.source-nginx .co2 {color: #339933;}
.nginx.source-nginx .coMULTI {color: #808080; font-style: italic;}
.nginx.source-nginx .es0 {color: #000099; font-weight: bold;}
.nginx.source-nginx .br0 {color: #66cc66;}
.nginx.source-nginx .sy0 {color: #66cc66;}
.nginx.source-nginx .st0 {color: #ff0000;}
.nginx.source-nginx .me1 {color: #202020;}
.nginx.source-nginx .me2 {color: #202020;}
.nginx.source-nginx .ln-xtra, .nginx.source-nginx li.ln-xtra, .nginx.source-nginx div.ln-xtra {background-color: #ffc;}
.nginx.source-nginx span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-lua {line-height: normal;}
.source-lua li, .source-lua pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for lua
 * CSS class: source-lua, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.lua.source-lua .de1, .lua.source-lua .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.lua.source-lua  {font-family:monospace;}
.lua.source-lua .imp {font-weight: bold; color: red;}
.lua.source-lua li, .lua.source-lua .li1 {font-weight: normal; vertical-align:top;}
.lua.source-lua .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.lua.source-lua .li2 {font-weight: bold; vertical-align:top;}
.lua.source-lua .kw1 {color: #b1b100;}
.lua.source-lua .co1 {color: #808080; font-style: italic;}
.lua.source-lua .coMULTI {color: #808080; font-style: italic;}
.lua.source-lua .es0 {color: #000099; font-weight: bold;}
.lua.source-lua .br0 {color: #66cc66;}
.lua.source-lua .sy0 {color: #66cc66;}
.lua.source-lua .st0 {color: #ff0000;}
.lua.source-lua .nu0 {color: #cc66cc;}
.lua.source-lua .me0 {color: #b1b100;}
.lua.source-lua .ln-xtra, .lua.source-lua li.ln-xtra, .lua.source-lua div.ln-xtra {background-color: #ffc;}
.lua.source-lua span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-bash {line-height: normal;}
.source-bash li, .source-bash pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for bash
 * CSS class: source-bash, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.bash.source-bash .de1, .bash.source-bash .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.bash.source-bash  {font-family:monospace;}
.bash.source-bash .imp {font-weight: bold; color: red;}
.bash.source-bash li, .bash.source-bash .li1 {font-weight: normal; vertical-align:top;}
.bash.source-bash .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.bash.source-bash .li2 {font-weight: bold; vertical-align:top;}
.bash.source-bash .kw1 {color: #000000; font-weight: bold;}
.bash.source-bash .kw2 {color: #c20cb9; font-weight: bold;}
.bash.source-bash .kw3 {color: #7a0874; font-weight: bold;}
.bash.source-bash .co0 {color: #666666; font-style: italic;}
.bash.source-bash .co1 {color: #800000;}
.bash.source-bash .co2 {color: #cc0000; font-style: italic;}
.bash.source-bash .co3 {color: #000000; font-weight: bold;}
.bash.source-bash .es1 {color: #000099; font-weight: bold;}
.bash.source-bash .es2 {color: #007800;}
.bash.source-bash .es3 {color: #007800;}
.bash.source-bash .es4 {color: #007800;}
.bash.source-bash .es5 {color: #780078;}
.bash.source-bash .es_h {color: #000099; font-weight: bold;}
.bash.source-bash .br0 {color: #7a0874; font-weight: bold;}
.bash.source-bash .sy0 {color: #000000; font-weight: bold;}
.bash.source-bash .st0 {color: #ff0000;}
.bash.source-bash .st_h {color: #ff0000;}
.bash.source-bash .nu0 {color: #000000;}
.bash.source-bash .re0 {color: #007800;}
.bash.source-bash .re1 {color: #007800;}
.bash.source-bash .re2 {color: #007800;}
.bash.source-bash .re4 {color: #007800;}
.bash.source-bash .re5 {color: #660033;}
.bash.source-bash .ln-xtra, .bash.source-bash li.ln-xtra, .bash.source-bash div.ln-xtra {background-color: #ffc;}
.bash.source-bash span.xtra { display:block; }

/*]]>*/
</style>
          <style>
	.editsection, #toolbar, #user-tools { display: none; }      
      </style>
      </head>

  <body
    <div id="globalWrapper">
	<div id="content">
	  
	  
            

	  <h1 class="firstHeading">HttpLuaModule</h1>

	  <div id="bodyContent">
	     
	    	    	    
	    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=1" title="Edit section: Name">edit</a>]</span> <span class="mw-headline" id="Name"> Name </span></h1>
<p>ngx_lua - Embed the power of Lua into Nginx
</p><p><i>This module is not distributed with the Nginx source.</i> See <a href="#Installation">the installation instructions</a>.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=2" title="Edit section: Status">edit</a>]</span> <span class="mw-headline" id="Status"> Status </span></h1>
<p>This module is under active development and is production ready.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=3" title="Edit section: Version">edit</a>]</span> <span class="mw-headline" id="Version"> Version </span></h1>
<p>This document describes ngx_lua <a rel="nofollow" class="external text" href="https://github.com/chaoslawful/lua-nginx-module/tags">v0.9.0</a> released on 29 September 2013.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=4" title="Edit section: Synopsis">edit</a>]</span> <span class="mw-headline" id="Synopsis"> Synopsis </span></h1>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <span class="co1"># set search paths for pure Lua external libraries (';;' is the default path):</span>
    lua_package_path <span class="st0">'/foo/bar/?.lua;/blah/?.lua;;'</span><span class="sy0">;</span>
&nbsp;
    <span class="co1"># set search paths for Lua external libraries written in C (can also use ';;'):</span>
    lua_package_cpath <span class="st0">'/bar/baz/?.so;/blah/blah/?.so;;'</span><span class="sy0">;</span>
&nbsp;
    <a href="/NginxHttpCoreModule#server"><span class="kw3">server</span></a> <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /inline_concat <span class="br0">{</span>
            <span class="co1"># MIME type determined by default_type:</span>
            <a href="/NginxHttpCoreModule#default_type"><span class="kw3">default_type</span></a> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="st0">"hello"</span><span class="sy0">;</span>
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">"world"</span><span class="sy0">;</span>
            <span class="co1"># inline Lua script</span>
            set_by_lua <span class="re0">$res</span> <span class="st0">"return ngx.arg[1]..ngx.arg[2]"</span> <span class="re0">$a</span> <span class="re0">$b</span><span class="sy0">;</span>
            echo <span class="re0">$res</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /rel_file_concat <span class="br0">{</span>
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="st0">"foo"</span><span class="sy0">;</span>
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">"bar"</span><span class="sy0">;</span>
            <span class="co1"># script path relative to nginx prefix</span>
            <span class="co1"># $ngx_prefix/conf/concat.lua contents:</span>
            <span class="co1">#</span>
            <span class="co1">#    return ngx.arg[1]..ngx.arg[2]</span>
            <span class="co1">#</span>
            set_by_lua_file <span class="re0">$res</span> conf/concat.lua <span class="re0">$a</span> <span class="re0">$b</span><span class="sy0">;</span>
            echo <span class="re0">$res</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /abs_file_concat <span class="br0">{</span>
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="st0">"fee"</span><span class="sy0">;</span>
            <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">"baz"</span><span class="sy0">;</span>
            <span class="co1"># absolute script path not modified</span>
            set_by_lua_file <span class="re0">$res</span> /usr/nginx/conf/concat.lua <span class="re0">$a</span> <span class="re0">$b</span><span class="sy0">;</span>
            echo <span class="re0">$res</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua_content <span class="br0">{</span>
            <span class="co1"># MIME type determined by default_type:</span>
            <a href="/NginxHttpCoreModule#default_type"><span class="kw3">default_type</span></a> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
            content_by_lua <span class="st0">"ngx.say('Hello,world!')"</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
         <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /nginx_var <span class="br0">{</span>
            <span class="co1"># MIME type determined by default_type:</span>
            <a href="/NginxHttpCoreModule#default_type"><span class="kw3">default_type</span></a> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
            <span class="co1"># try access /nginx_var?a=hello,world</span>
            content_by_lua <span class="st0">"ngx.print(ngx.var['arg_a'], '<span class="es0">\\</span>n')"</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /request_body <span class="br0">{</span>
             <span class="co1"># force reading request body (default off)</span>
             lua_need_request_body on<span class="sy0">;</span>
             <a href="/NginxHttpCoreModule#client_max_body_size"><span class="kw3">client_max_body_size</span></a> 50k<span class="sy0">;</span>
             <a href="/NginxHttpCoreModule#client_body_buffer_size"><span class="kw3">client_body_buffer_size</span></a> 50k<span class="sy0">;</span>
&nbsp;
             content_by_lua <span class="st0">'ngx.print(ngx.var.request_body)'</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <span class="co1"># transparent non-blocking I/O in Lua via subrequests</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
            <span class="co1"># MIME type determined by default_type:</span>
            <a href="/NginxHttpCoreModule#default_type"><span class="kw3">default_type</span></a> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
            content_by_lua <span class="st0">'
                local res = ngx.location.capture("/some_other_location")
                if res.status == 200 then
                    ngx.print(res.body)
                end'</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <span class="co1"># GET /recur?num=5</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /recur <span class="br0">{</span>
            <span class="co1"># MIME type determined by default_type:</span>
            <a href="/NginxHttpCoreModule#default_type"><span class="kw3">default_type</span></a> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
            content_by_lua <span class="st0">'
               local num = tonumber(ngx.var.arg_num) or 0
&nbsp;
               if num &gt; 50 then
                   ngx.say("num too big")
                   return
               end
&nbsp;
               ngx.say("num is: ", num)
&nbsp;
               if num &gt; 0 then
                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
                   ngx.print("status=", res.status, " ")
                   ngx.print("body=", res.body)
               else
                   ngx.say("end")
               end
               '</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
            rewrite_by_lua <span class="st0">'
                res = ngx.location.capture("/memc",
                    { args = { cmd = "incr", key = ngx.var.uri } }
                )
            '</span><span class="sy0">;</span>
&nbsp;
            <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://blah.blah.com<span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /blah <span class="br0">{</span>
            access_by_lua <span class="st0">'
                local res = ngx.location.capture("/auth")
&nbsp;
                if res.status == ngx.HTTP_OK then
                    return
                end
&nbsp;
                if res.status == ngx.HTTP_FORBIDDEN then
                    ngx.exit(res.status)
                end
&nbsp;
                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            '</span><span class="sy0">;</span>
&nbsp;
            <span class="co1"># proxy_pass/fastcgi_pass/postgres_pass/...</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /mixed <span class="br0">{</span>
            rewrite_by_lua_file /path/to/<a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a>.lua<span class="sy0">;</span>
            access_by_lua_file /path/to/access.lua<span class="sy0">;</span>
            content_by_lua_file /path/to/content.lua<span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <span class="co1"># use nginx var in code path</span>
        <span class="co1"># WARN: contents in nginx var must be carefully filtered,</span>
        <span class="co1"># otherwise there'll be great security risk!</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">~</span> ^/app/<span class="br0">(</span>.+<span class="br0">)</span> <span class="br0">{</span>
                content_by_lua_file /path/to/lua/app/<a href="/NginxHttpCoreModule#root"><span class="kw3">root</span></a>/$<span class="nu0">1</span>.lua<span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
           lua_need_request_body on<span class="sy0">;</span>
&nbsp;
           <a href="/NginxHttpCoreModule#client_max_body_size"><span class="kw3">client_max_body_size</span></a> 100k<span class="sy0">;</span>
           <a href="/NginxHttpCoreModule#client_body_buffer_size"><span class="kw3">client_body_buffer_size</span></a> 100k<span class="sy0">;</span>
&nbsp;
           access_by_lua <span class="st0">'
               -- check the client IP address is in our black list
               if ngx.var.remote_addr == "132.5.72.3" then
                   ngx.exit(ngx.HTTP_FORBIDDEN)
               end
&nbsp;
               -- check if the request body contains bad words
               if ngx.var.request_body and
                        string.match(ngx.var.request_body, "fsck")
               then
                   return ngx.redirect("/terms_of_use.html")
               end
&nbsp;
               -- tests passed
           '</span><span class="sy0">;</span>
&nbsp;
           <span class="co1"># proxy_pass/fastcgi_pass/etc settings</span>
        <span class="br0">}</span>
    <span class="br0">}</span></pre></div></div>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=5" title="Edit section: Description">edit</a>]</span> <span class="mw-headline" id="Description"> Description </span></h1>
<p>This module embeds Lua, via the standard Lua 5.1 interpreter or <a rel="nofollow" class="external text" href="http://luajit.org/luajit.html">LuaJIT 2.0</a>, into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.
</p><p>Unlike <a rel="nofollow" class="external text" href="http://httpd.apache.org/docs/2.3/mod/mod_lua.html">Apache's mod_lua</a> and <a rel="nofollow" class="external text" href="http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet">Lighttpd's mod_magnet</a>, Lua code executed using this module can be <i>100% non-blocking</i> on network traffic as long as the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a> provided by this module is used to handle
requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.
</p><p>At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:
</p>
<ul><li> <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-memcached">lua-resty-memcached</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-mysql">lua-resty-mysql</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-redis">lua-resty-redis</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-dns">lua-resty-dns</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-upload">lua-resty-upload</a>
</li><li> <a href="/HttpMemcModule" title="HttpMemcModule">ngx_memc</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/FRiCKLE/ngx_postgres">ngx_postgres</a>
</li><li> <a href="/HttpRedis2Module" title="HttpRedis2Module">ngx_redis2</a>
</li><li> <a href="/HttpRedisModule" title="HttpRedisModule" class="mw-redirect">ngx_redis</a>
</li><li> <a href="/HttpProxyModule" title="HttpProxyModule">ngx_proxy</a>
</li><li> <a href="/HttpFastcgiModule" title="HttpFastcgiModule">ngx_fastcgi</a>
</li></ul>
<p>Almost all the Nginx modules can be used with this ngx_lua module by means of <a href="#ngx.location.capture">ngx.location.capture</a> or <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> but it is recommended to use those <code>lua-resty-*</code> libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.
</p><p>The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.
</p><p>Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=6" title="Edit section: Directives">edit</a>]</span> <span class="mw-headline" id="Directives"> Directives </span></h1>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=7" title="Edit section: lua code cache">edit</a>]</span> <span class="mw-headline" id="lua_code_cache"> lua_code_cache </span></h2>
<p><b>syntax:</b> <i>lua_code_cache on | off</i>
</p><p><b>default:</b> <i>lua_code_cache on</i>
</p><p><b>context:</b> <i>main, server, location, location if</i>
</p><p>Enables or disables the Lua code cache for <a href="#set_by_lua_file">set_by_lua_file</a>,
<a href="#content_by_lua_file">content_by_lua_file</a>, <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a>, and
<a href="#access_by_lua_file">access_by_lua_file</a>, and also force Lua module reloading on a per-request basis.
</p><p>The Lua files referenced in <a href="#set_by_lua_file">set_by_lua_file</a>,
<a href="#content_by_lua_file">content_by_lua_file</a>, <a href="#access_by_lua_file">access_by_lua_file</a>,
and <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a> will not be cached
and the Lua <code>package.loaded</code> table will be cleared
at the entry point of every request (such that Lua modules
will not be cached either). With this in place, developers can adopt an edit-and-refresh approach.
</p><p>Please note however, that Lua code written inlined within nginx.conf
such as those specified by <a href="#set_by_lua">set_by_lua</a>, <a href="#content_by_lua">content_by_lua</a>,
<a href="#access_by_lua">access_by_lua</a>, and <a href="#rewrite_by_lua">rewrite_by_lua</a> will <i>always</i> be
cached because only the Nginx config file parser can correctly parse the <code>nginx.conf</code>
file and the only ways to to reload the config file
are to send a <code>HUP</code> signal or to restart Nginx.
</p><p>Also, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code>
in *_by_lua_file will never be cached. To ensure code caching, you can either use the <a href="#init_by_lua">init_by_lua</a>
or <a href="#init-by_lua_file">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules
and load them via <code>require</code>.
</p><p>The ngx_lua module does not currently support the <code>stat</code> mode available with the
Apache <code>mod_lua</code> module but this is planned for implementation in the future.
</p><p>Disabling the Lua code cache is strongly
discouraged for production use and should only be used during 
development as it has a significant negative impact on overall performance.
In addition, race conditions when reloading Lua modules are common for concurrent requests
when the code cache is disabled.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=8" title="Edit section: lua regex cache max entries">edit</a>]</span> <span class="mw-headline" id="lua_regex_cache_max_entries"> lua_regex_cache_max_entries </span></h2>
<p><b>syntax:</b> <i>lua_regex_cache_max_entries &lt;num&gt;</i>
</p><p><b>default:</b> <i>lua_regex_cache_max_entries 1024</i>
</p><p><b>context:</b> <i>http</i>
</p><p>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.
</p><p>The regular expressions used in <a href="#ngx.re.match">ngx.re.match</a>, <a href="#ngx.re.gmatch">ngx.re.gmatch</a>, <a href="#ngx.re.sub">ngx.re.sub</a>, and <a href="#ngx.re.gsub">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.
</p><p>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...</pre></div></div>
<p>Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href="#ngx.re.sub">ngx.re.sub</a> and <a href="#ngx.re.gsub">ngx.re.gsub</a>) that are generated <i>on the fly</i> and give rise to infinite variations to avoid hitting the specified limit.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=9" title="Edit section: lua regex match limit">edit</a>]</span> <span class="mw-headline" id="lua_regex_match_limit"> lua_regex_match_limit </span></h2>
<p><b>syntax:</b> <i>lua_regex_match_limit &lt;num&gt;</i>
</p><p><b>default:</b> <i>lua_regex_match_limit 0</i>
</p><p><b>context:</b> <i>http</i>
</p><p>Specifies the "match limit" used by the PCRE library when executing the <a href="#ngx.re.match">ngx.re API</a>. To quote the PCRE manpage, "the limit ... has the effect of limiting the amount of backtracking that can take place."
</p><p>When the limit is hit, the error string "pcre_exec() failed: -8" will be returned by the <a href="#ngx.re.match">ngx.re API</a> functions on the Lua land.
</p><p>When setting the limit to 0, the default "match limit" when compiling the PCRE library is used. And this is the default value of this directive.
</p><p>This directive was first introduced in the <code>v0.8.5</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=10" title="Edit section: lua package path">edit</a>]</span> <span class="mw-headline" id="lua_package_path"> lua_package_path </span></h2>
<p><b>syntax:</b> <i>lua_package_path &lt;lua-style-path-str&gt;</i>
</p><p><b>default:</b> <i>The content of LUA_PATH environ variable or Lua's compiled-in defaults.</i>
</p><p><b>context:</b> <i>main</i>
</p><p>Sets the Lua module search path used by scripts specified by <a href="#set_by_lua">set_by_lua</a>,
<a href="#content_by_lua">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code>
can be used to stand for the original search paths.
</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=11" title="Edit section: lua package cpath">edit</a>]</span> <span class="mw-headline" id="lua_package_cpath"> lua_package_cpath </span></h2>
<p><b>syntax:</b> <i>lua_package_cpath &lt;lua-style-cpath-str&gt;</i>
</p><p><b>default:</b> <i>The content of LUA_CPATH environment variable or Lua's compiled-in defaults.</i>
</p><p><b>context:</b> <i>main</i>
</p><p>Sets the Lua C-module search path used by scripts specified by <a href="#set_by_lua">set_by_lua</a>,
<a href="#content_by_lua">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code>
can be used to stand for the original cpath.
</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=12" title="Edit section: init by lua">edit</a>]</span> <span class="mw-headline" id="init_by_lua"> init_by_lua </span></h2>
<p><b>syntax:</b> <i>init_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http</i>
</p><p><b>phase:</b> <i>loading-config</i>
</p><p>Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.
</p><p>When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code> will run again on the new Lua VM.
</p><p>Usually you can register (true) Lua global variables or pre-load Lua modules at server start-up by means of this hook. Here is an example for pre-loading Lua modules:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    init_by_lua <span class="st0">'cjson = require "cjson"'</span><span class="sy0">;</span>
&nbsp;
    <a href="/NginxHttpCoreModule#server"><span class="kw3">server</span></a> <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /api <span class="br0">{</span>
            content_by_lua <span class="st0">'
                ngx.say(cjson.encode({dog = 5, cat = 6}))
            '</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span></pre></div></div>
<p>You can also initialize the <a href="#lua_shared_dict">lua_shared_dict</a> shm storage at this phase. Here is an example for this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    lua_shared_dict dogs 1m<span class="sy0">;</span>
&nbsp;
    init_by_lua <span class="st0">'
        local dogs = ngx.shared.dogs;
        dogs:set("Tom", 56)
    '</span><span class="sy0">;</span>
&nbsp;
    <a href="/NginxHttpCoreModule#server"><span class="kw3">server</span></a> <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /api <span class="br0">{</span>
            content_by_lua <span class="st0">'
                local dogs = ngx.shared.dogs;
                ngx.say(dogs:get("Tom"))
            '</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span></pre></div></div>
<p>But note that, the <a href="#lua_shared_dict">lua_shared_dict</a>'s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <i>not</i> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.
</p><p>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Copy-on-write">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.
</p><p>Only a small set of the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a> is supported in this context:
</p>
<ul><li> Logging APIs: <a href="#ngx.log">ngx.log</a> and <a href="#print">print</a>,
</li><li> Shared Dictionary API: <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</li></ul>
<p>More Nginx APIs for Lua may be supported in this context upon future user requests.
</p><p>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.
</p><p>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.
</p><p>This directive was first introduced in the <code>v0.5.5</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=13" title="Edit section: init by lua file">edit</a>]</span> <span class="mw-headline" id="init_by_lua_file"> init_by_lua_file </span></h2>
<p><b>syntax:</b> <i>init_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http</i>
</p><p><b>phase:</b> <i>loading-config</i>
</p><p>Equivalent to <a href="#init_by_lua">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>This directive was first introduced in the <code>v0.5.5</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=14" title="Edit section: set by lua">edit</a>]</span> <span class="mw-headline" id="set_by_lua"> set_by_lua </span></h2>
<p><b>syntax:</b> <i>set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]</i>
</p><p><b>context:</b> <i>server, server if, location, location if</i>
</p><p><b>phase:</b> <i>server-rewrite, rewrite</i>
</p><p>Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. 
The code in <code>&lt;lua-script-str&gt;</code> can make <a href="#Nginx_API_for_Lua">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).
</p><p>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.
</p><p>Note that the following API functions are currently disabled within this context:
</p>
<ul><li> Output API functions (e.g., <a href="#ngx.say">ngx.say</a> and <a href="#ngx.send_headers">ngx.send_headers</a>)
</li><li> Control API functions (e.g., <a href="#ngx.exit">ngx.exit</a>) 
</li><li> Subrequest API functions (e.g., <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>)
</li><li> Cosocket API functions (e.g., <a href="#ngx.socket.tcp">ngx.socket.tcp</a> and <a href="#ngx.req.socket">ngx.req.socket</a>).
</li></ul>
<p>In addition, note that this directive can only write out a value to a single Nginx variable at
a time. However, a workaround is possible using the <a href="#ngx.var.VARIABLE">ngx.var.VARIABLE</a> interface.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$diff</span> <span class="st0">''</span><span class="sy0">;</span> <span class="co1"># we have to predefine the $diff variable here</span>
&nbsp;
        set_by_lua <span class="re0">$sum</span> <span class="st0">'
            local a = 32
            local b = 56
&nbsp;
            ngx.var.diff = a - b;  -- write to $diff directly
            return a + b;          -- return the $sum value normally
        '</span><span class="sy0">;</span>
&nbsp;
        echo <span class="st0">"sum = $sum, diff = $diff"</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>This directive can be freely mixed with all directives of the <a href="/HttpRewriteModule" title="HttpRewriteModule">HttpRewriteModule</a>, <a href="/HttpSetMiscModule" title="HttpSetMiscModule">HttpSetMiscModule</a>, and <a href="/HttpArrayVarModule" title="HttpArrayVarModule">HttpArrayVarModule</a> modules. All of these directives will run in the same order as they appear in the config file.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$foo</span> <span class="nu0">32</span><span class="sy0">;</span>
    set_by_lua <span class="re0">$bar</span> <span class="st0">'tonumber(ngx.var.foo) + 1'</span><span class="sy0">;</span>
    <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$baz</span> <span class="st0">"bar: $bar"</span><span class="sy0">;</span>  <span class="co1"># $baz == "bar: 33"</span></pre></div></div>
<p>As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.
</p><p>This directive requires the <a rel="nofollow" class="external text" href="https://github.com/simpl/ngx_devel_kit">ngx_devel_kit</a> module.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=15" title="Edit section: set by lua file">edit</a>]</span> <span class="mw-headline" id="set_by_lua_file"> set_by_lua_file </span></h2>
<p><b>syntax:</b> <i>set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]</i>
</p><p><b>context:</b> <i>server, server if, location, location if</i>
</p><p><b>phase:</b> <i>server-rewrite, rewrite</i>
</p><p>Equivalent to <a href="#set_by_lua">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed. 
</p><p>Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by 
switching <a href="#lua_code_cache">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
</p><p>This directive requires the <a rel="nofollow" class="external text" href="https://github.com/simpl/ngx_devel_kit">ngx_devel_kit</a> module.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=16" title="Edit section: content by lua">edit</a>]</span> <span class="mw-headline" id="content_by_lua"> content_by_lua </span></h2>
<p><b>syntax:</b> <i>content_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>location, location if</i>
</p><p><b>phase:</b> <i>content</i>
</p><p>Acts as a "content handler" and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. 
The Lua code may make <a href="#Nginx_API_for_Lua">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
</p><p>Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href="/HttpProxyModule#proxy_pass" title="HttpProxyModule">proxy_pass</a> directive should not be used in the same location.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=17" title="Edit section: content by lua file">edit</a>]</span> <span class="mw-headline" id="content_by_lua_file"> content_by_lua_file </span></h2>
<p><b>syntax:</b> <i>content_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>location, location if</i>
</p><p><b>phase:</b> <i>content</i>
</p><p>Equivalent to <a href="#content_by_lua">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by 
switching <a href="#lua_code_cache">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=18" title="Edit section: rewrite by lua">edit</a>]</span> <span class="mw-headline" id="rewrite_by_lua"> rewrite_by_lua </span></h2>
<p><b>syntax:</b> <i>rewrite_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>rewrite tail</i>
</p><p>Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.
The Lua code may make <a href="#Nginx_API_for_Lua">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
</p><p>Note that this handler always runs <i>after</i> the standard <a href="/HttpRewriteModule" title="HttpRewriteModule">HttpRewriteModule</a>. So the following will work as expected:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">   <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
       <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="nu0">12</span><span class="sy0">;</span> <span class="co1"># create and initialize $a</span>
       <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">""</span><span class="sy0">;</span> <span class="co1"># create and initialize $b</span>
       rewrite_by_lua <span class="st0">'ngx.var.b = tonumber(ngx.var.a) + 1'</span><span class="sy0">;</span>
       echo <span class="st0">"res = $b"</span><span class="sy0">;</span>
   <span class="br0">}</span></pre></div></div>
<p>because <code>set $a 12</code> and <code>set $b ""</code> run <i>before</i> <a href="#rewrite_by_lua">rewrite_by_lua</a>.
</p><p>On the other hand, the following will not work as expected:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">   &nbsp;?  <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
   &nbsp;?      <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="nu0">12</span><span class="sy0">;</span> <span class="co1"># create and initialize $a</span>
   &nbsp;?      <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">''</span><span class="sy0">;</span> <span class="co1"># create and initialize $b</span>
   &nbsp;?      rewrite_by_lua <span class="st0">'ngx.var.b = tonumber(ngx.var.a) + 1'</span><span class="sy0">;</span>
   &nbsp;?      <a href="/NginxHttpRewriteModule#if"><span class="kw22">if</span></a> <span class="br0">(</span><span class="re0">$b</span> <span class="sy0">=</span> <span class="st0">'13'</span><span class="br0">)</span> <span class="br0">{</span>
   &nbsp;?         <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /bar redirect<span class="sy0">;</span>
   &nbsp;?         <a href="/NginxHttpRewriteModule#break"><span class="kw22">break</span></a><span class="sy0">;</span>
   &nbsp;?      <span class="br0">}</span>
   &nbsp;?
   &nbsp;?      echo <span class="st0">"res = $b"</span><span class="sy0">;</span>
   &nbsp;?  <span class="br0">}</span></pre></div></div>
<p>because <code>if</code> runs <i>before</i> <a href="#rewrite_by_lua">rewrite_by_lua</a> even if it is placed after <a href="#rewrite_by_lua">rewrite_by_lua</a> in the config.
</p><p>The right way of doing this is as follows:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="nu0">12</span><span class="sy0">;</span> <span class="co1"># create and initialize $a</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="st0">''</span><span class="sy0">;</span> <span class="co1"># create and initialize $b</span>
        rewrite_by_lua <span class="st0">'
            ngx.var.b = tonumber(ngx.var.a) + 1
            if tonumber(ngx.var.b) == 13 then
                return ngx.redirect("/bar");
            end
        '</span><span class="sy0">;</span>
&nbsp;
        echo <span class="st0">"res = $b"</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Note that the <a rel="nofollow" class="external text" href="http://www.grid.net.ru/nginx/eval.en.html">ngx_eval</a> module can be approximated by using <a href="#rewrite_by_lua">rewrite_by_lua</a>. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        eval <span class="re0">$res</span> <span class="br0">{</span>
            <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://foo.com/check-spam<span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpRewriteModule#if"><span class="kw22">if</span></a> <span class="br0">(</span><span class="re0">$res</span> <span class="sy0">=</span> <span class="st0">'spam'</span><span class="br0">)</span> <span class="br0">{</span>
            <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /terms-of-<a href="/NginxHttpEventsModule#use"><span class="kw2">use</span></a>.html redirect<span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpFcgiModule#fastcgi_pass"><span class="kw11">fastcgi_pass</span></a> ...<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>can be implemented in ngx_lua as:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /check-spam <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#internal"><span class="kw3">internal</span></a><span class="sy0">;</span>
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://foo.com/check-spam<span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        rewrite_by_lua <span class="st0">'
            local res = ngx.location.capture("/check-spam")
            if res.body == "spam" then
                return ngx.redirect("/terms-of-use.html")
            end
        '</span><span class="sy0">;</span>
&nbsp;
        <a href="/NginxHttpFcgiModule#fastcgi_pass"><span class="kw11">fastcgi_pass</span></a> ...<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Just as any other rewrite phase handlers, <a href="#rewrite_by_lua">rewrite_by_lua</a> also runs in subrequests.
</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="#rewrite_by_lua">rewrite_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="#rewrite_by_lua">rewrite_by_lua</a> handler, calling <a href="#ngx.exit">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.
</p><p>If the <a href="/HttpRewriteModule" title="HttpRewriteModule">HttpRewriteModule</a>'s <a href="/HttpRewriteModule#rewrite" title="HttpRewriteModule">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href="#rewrite_by_lua">rewrite_by_lua</a> or <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /bar<span class="sy0">;</span>
        rewrite_by_lua <span class="st0">'ngx.exit(503)'</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /bar <span class="br0">{</span>
        ...
    <span class="br0">}</span></pre></div></div>
<p>Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.
</p><p>The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a> is turned on.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=19" title="Edit section: rewrite by lua file">edit</a>]</span> <span class="mw-headline" id="rewrite_by_lua_file"> rewrite_by_lua_file </span></h2>
<p><b>syntax:</b> <i>rewrite_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>rewrite tail</i>
</p><p>Equivalent to <a href="#rewrite_by_lua">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="#lua_code_cache">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.
</p><p>The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a> is turned on.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=20" title="Edit section: access by lua">edit</a>]</span> <span class="mw-headline" id="access_by_lua"> access_by_lua </span></h2>
<p><b>syntax:</b> <i>access_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>access tail</i>
</p><p>Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.
The Lua code may make <a href="#Nginx_API_for_Lua">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).
</p><p>Note that this handler always runs <i>after</i> the standard <a href="/HttpAccessModule" title="HttpAccessModule">HttpAccessModule</a>. So the following will work as expected:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        <a href="/NginxHttpAccessModule#deny"><span class="kw5">deny</span></a>    192.168.1.1<span class="sy0">;</span>
        <a href="/NginxHttpAccessModule#allow"><span class="kw5">allow</span></a>   192.168.1.0/<span class="nu0">24</span><span class="sy0">;</span>
        <a href="/NginxHttpAccessModule#allow"><span class="kw5">allow</span></a>   10.1.1.0/<span class="nu0">16</span><span class="sy0">;</span>
        <a href="/NginxHttpAccessModule#deny"><span class="kw5">deny</span></a>    all<span class="sy0">;</span>
&nbsp;
        access_by_lua <span class="st0">'
            local res = ngx.location.capture("/mysql", { ... })
            ...
        '</span><span class="sy0">;</span>
&nbsp;
        <span class="co1"># proxy_pass/fastcgi_pass/...</span>
    <span class="br0">}</span></pre></div></div>
<p>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href="#access_by_lua">access_by_lua</a>.
</p><p>Note that the <a rel="nofollow" class="external text" href="http://mdounin.ru/hg/ngx_http_auth_request_module/">ngx_auth_request</a> module can be approximated by using <a href="#access_by_lua">access_by_lua</a>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        auth_request /auth<span class="sy0">;</span>
&nbsp;
        <span class="co1"># proxy_pass/fastcgi_pass/postgres_pass/...</span>
    <span class="br0">}</span></pre></div></div>
<p>can be implemented in ngx_lua as:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        access_by_lua <span class="st0">'
            local res = ngx.location.capture("/auth")
&nbsp;
            if res.status == ngx.HTTP_OK then
                return
            end
&nbsp;
            if res.status == ngx.HTTP_FORBIDDEN then
                ngx.exit(res.status)
            end
&nbsp;
            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        '</span><span class="sy0">;</span>
&nbsp;
        <span class="co1"># proxy_pass/fastcgi_pass/postgres_pass/...</span>
    <span class="br0">}</span></pre></div></div>
<p>As with other access phase handlers, <a href="#access_by_lua">access_by_lua</a> will <i>not</i> run in subrequests.
</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="#access_by_lua">access_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="#access_by_lua">access_by_lua</a> handler, calling <a href="#ngx.exit">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=21" title="Edit section: access by lua file">edit</a>]</span> <span class="mw-headline" id="access_by_lua_file"> access_by_lua_file </span></h2>
<p><b>syntax:</b> <i>access_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>access tail</i>
</p><p>Equivalent to <a href="#access_by_lua">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by switching <a href="#lua_code_cache">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=22" title="Edit section: header filter by lua">edit</a>]</span> <span class="mw-headline" id="header_filter_by_lua"> header_filter_by_lua </span></h2>
<p><b>syntax:</b> <i>header_filter_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>output-header-filter</i>
</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.
</p><p>Note that the following API functions are currently disabled within this context:
</p>
<ul><li> Output API functions (e.g., <a href="#ngx.say">ngx.say</a> and <a href="#ngx.send_headers">ngx.send_headers</a>)
</li><li> Control API functions (e.g., <a href="#ngx.exit">ngx.exit</a> and <a href="#ngx.exec">ngx.exec</a>)
</li><li> Subrequest API functions (e.g., <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>)
</li><li> Cosocket API functions (e.g., <a href="#ngx.socket.tcp">ngx.socket.tcp</a> and <a href="#ngx.req.socket">ngx.req.socket</a>).
</li></ul>
<p>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://mybackend<span class="sy0">;</span>
        header_filter_by_lua <span class="st0">'ngx.header.Foo = "blah"'</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>This directive was first introduced in the <code>v0.2.1rc20</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=23" title="Edit section: header filter by lua file">edit</a>]</span> <span class="mw-headline" id="header_filter_by_lua_file"> header_filter_by_lua_file </span></h2>
<p><b>syntax:</b> <i>header_filter_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>output-header-filter</i>
</p><p>Equivalent to <a href="#header_filter_by_lua">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=24" title="Edit section: body filter by lua">edit</a>]</span> <span class="mw-headline" id="body_filter_by_lua"> body_filter_by_lua </span></h2>
<p><b>syntax:</b> <i>body_filter_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>output-body-filter</i>
</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.
</p><p>The input data chunk is passed via <a href="#ngx.arg">ngx.arg</a>[1] (as a Lua string value) and the "eof" flag indicating the end of the response body data stream is passed via <a href="#ngx.arg">ngx.arg</a>[2] (as a Lua boolean value).
</p><p>Behind the scene, the "eof" flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the "eof" flag does not work at all in subrequests.)
</p><p>The output data stream can be aborted immediately by running the following Lua statement:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.ERROR</pre></div></div>
<p>This will truncate the response body and usually result in incomplete and also invalid responses.
</p><p>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href="#ngx.arg">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://mybackend<span class="sy0">;</span>
        body_filter_by_lua <span class="st0">'ngx.arg[1] = string.upper(ngx.arg[1])'</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.
</p><p>Likewise, new "eof" flag can also be specified by setting a boolean value to <a href="#ngx.arg">ngx.arg</a>[2]. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /t <span class="br0">{</span>
        echo hello world<span class="sy0">;</span>
        echo hiya globe<span class="sy0">;</span>
&nbsp;
        body_filter_by_lua <span class="st0">'
            local chunk = ngx.arg[1]
            if string.match(chunk, "hello") then
                ngx.arg[2] = true  -- new eof
                return
            end
&nbsp;
            -- just throw away any remaining chunk data
            ngx.arg[1] = nil
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then <code>GET /t</code> will just return the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    hello world</pre></div></div>
<p>That is, when the body filter sees a chunk containing the word "hello", then it will set the "eof" flag to true immediately, resulting in truncated but still valid responses.
</p><p>When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code> response header (if any) in a header filter to enforce streaming output, as in
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <span class="co1"># fastcgi_pass/proxy_pass/...</span>
&nbsp;
        header_filter_by_lua <span class="st0">'ngx.header.content_length = nil'</span><span class="sy0">;</span>
        body_filter_by_lua <span class="st0">'ngx.arg[1] = string.len(ngx.arg[1]) .. "<span class="es0">\\</span>n"'</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Note that the following API functions are currently disabled within this context:
</p>
<ul><li> Output API functions (e.g., <a href="#ngx.say">ngx.say</a> and <a href="#ngx.send_headers">ngx.send_headers</a>)
</li><li> Control API functions (e.g., <a href="#ngx.exit">ngx.exit</a> and <a href="#ngx.exec">ngx.exec</a>)
</li><li> Subrequest API functions (e.g., <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>)
</li><li> Cosocket API functions (e.g., <a href="#ngx.socket.tcp">ngx.socket.tcp</a> and <a href="#ngx.req.socket">ngx.req.socket</a>).
</li></ul>
<p>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.
</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=25" title="Edit section: body filter by lua file">edit</a>]</span> <span class="mw-headline" id="body_filter_by_lua_file"> body_filter_by_lua_file </span></h2>
<p><b>syntax:</b> <i>body_filter_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>output-body-filter</i>
</p><p>Equivalent to <a href="#body_filter_by_lua">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=26" title="Edit section: log by lua">edit</a>]</span> <span class="mw-headline" id="log_by_lua"> log_by_lua </span></h2>
<p><b>syntax:</b> <i>log_by_lua &lt;lua-script-str&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>log</i>
</p><p>Run the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs after.
</p><p>Note that the following API functions are currently disabled within this context:
</p>
<ul><li> Output API functions (e.g., <a href="#ngx.say">ngx.say</a> and <a href="#ngx.send_headers">ngx.send_headers</a>)
</li><li> Control API functions (e.g., <a href="#ngx.exit">ngx.exit</a>) 
</li><li> Subrequest API functions (e.g., <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>)
</li><li> Cosocket API functions (e.g., <a href="#ngx.socket.tcp">ngx.socket.tcp</a> and <a href="#ngx.req.socket">ngx.req.socket</a>).
</li></ul>
<p>Here is an example of gathering average data for <a href="/HttpUpstreamModule#.24upstream_response_time" title="HttpUpstreamModule">$upstream_response_time</a>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    lua_shared_dict log_dict 5M<span class="sy0">;</span>
&nbsp;
    <a href="/NginxHttpCoreModule#server"><span class="kw3">server</span></a> <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
            <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://mybackend<span class="sy0">;</span>
&nbsp;
            log_by_lua <span class="st0">'
                local log_dict = ngx.shared.log_dict
                local upstream_time = tonumber(ngx.var.upstream_response_time)
&nbsp;
                local sum = log_dict:get("upstream_time-sum") or 0
                sum = sum + upstream_time
                log_dict:set("upstream_time-sum", sum)
&nbsp;
                local newval, err = log_dict:incr("upstream_time-nb", 1)
                if not newval and err == "not found" then
                    log_dict:add("upstream_time-nb", 0)
                    log_dict:incr("upstream_time-nb", 1)
                end
            '</span><span class="sy0">;</span>
        <span class="br0">}</span>
&nbsp;
        <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /status <span class="br0">{</span>
            content_by_lua <span class="st0">'
                local log_dict = ngx.shared.log_dict
                local sum = log_dict:get("upstream_time-sum")
                local nb = log_dict:get("upstream_time-nb")
&nbsp;
                if nb and sum then
                    ngx.say("average upstream response time: ", sum / nb,
                            " (", nb, " reqs)")
                else
                    ngx.say("no data yet")
                end
            '</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span></pre></div></div>
<p>This directive was first introduced in the <code>v0.5.0rc31</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=27" title="Edit section: log by lua file">edit</a>]</span> <span class="mw-headline" id="log_by_lua_file"> log_by_lua_file </span></h2>
<p><b>syntax:</b> <i>log_by_lua_file &lt;path-to-lua-script-file&gt;</i>
</p><p><b>context:</b> <i>http, server, location, location if</i>
</p><p><b>phase:</b> <i>log</i>
</p><p>Equivalent to <a href="#log_by_lua">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="#Lua.2FLuaJIT_bytecode_support">Lua/LuaJIT bytecode</a> to be executed.
</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.
</p><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=28" title="Edit section: lua need request body">edit</a>]</span> <span class="mw-headline" id="lua_need_request_body"> lua_need_request_body </span></h2>
<p><b>syntax:</b> <i>lua_need_request_body &lt;on|off&gt;</i>
</p><p><b>default:</b> <i>off</i>
</p><p><b>context:</b> <i>main | server | location</i>
</p><p><b>phase:</b> <i>depends on usage</i>
</p><p>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href="#ngx.req.read_body">ngx.req.read_body</a> function should be called within the Lua code.
</p><p>To read the request body data within the <a href="/HttpCoreModule#.24request_body" title="HttpCoreModule">$request_body</a> variable, 
<a href="/HttpCoreModule#client_body_buffer_size" title="HttpCoreModule">client_body_buffer_size</a> must have the same value as <a href="/HttpCoreModule#client_max_body_size" title="HttpCoreModule">client_max_body_size</a>. Because when the content length exceeds <a href="/HttpCoreModule#client_body_buffer_size" title="HttpCoreModule">client_body_buffer_size</a> but less than <a href="/HttpCoreModule#client_max_body_size" title="HttpCoreModule">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href="/HttpCoreModule#.24request_body" title="HttpCoreModule">$request_body</a> variable.
</p><p>If the current location includes <a href="#rewrite_by_lua">rewrite_by_lua</a> or <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a> directives,
then the request body will be read just before the <a href="#rewrite_by_lua">rewrite_by_lua</a> or <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a> code is run (and also at the
<code>rewrite</code> phase). Similarly, if only <a href="#content_by_lua">content_by_lua</a> is specified,
the request body will not be read until the content handler's Lua code is
about to run (i.e., the request body will be read during the content phase).
</p><p>It is recommended however, to use the <a href="#ngx.req.read_body">ngx.req.read_body</a> and <a href="#ngx.req.discard_body">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.
</p><p>This also applies to <a href="#access_by_lua">access_by_lua</a> and <a href="#access_by_lua_file">access_by_lua_file</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=29" title="Edit section: lua shared dict">edit</a>]</span> <span class="mw-headline" id="lua_shared_dict"> lua_shared_dict </span></h2>
<p><b>syntax:</b> <i>lua_shared_dict &lt;name&gt; &lt;size&gt;</i>
</p><p><b>default:</b> <i>no</i>
</p><p><b>context:</b> <i>http</i>
</p><p><b>phase:</b> <i>depends on usage</i>
</p><p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.
</p><p>The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a> <span class="br0">{</span>
        lua_shared_dict dogs 10m<span class="sy0">;</span>
        ...
    <span class="br0">}</span></pre></div></div>
<p>See <a href="#ngx.shared.DICT">ngx.shared.DICT</a> for details.
</p><p>This directive was first introduced in the <code>v0.3.1rc22</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=30" title="Edit section: lua socket connect timeout">edit</a>]</span> <span class="mw-headline" id="lua_socket_connect_timeout"> lua_socket_connect_timeout </span></h2>
<p><b>syntax:</b> <i>lua_socket_connect_timeout &lt;time&gt;</i>
</p><p><b>default:</b> <i>lua_socket_connect_timeout 60s</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>This directive controls the default timeout value used in TCP/unix-domain socket object's <a href="#tcpsock:connect">connect</a> method and can be overridden by the <a href="#tcpsock:settimeout">settimeout</a> method.
</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=31" title="Edit section: lua socket send timeout">edit</a>]</span> <span class="mw-headline" id="lua_socket_send_timeout"> lua_socket_send_timeout </span></h2>
<p><b>syntax:</b> <i>lua_socket_send_timeout &lt;time&gt;</i>
</p><p><b>default:</b> <i>lua_socket_send_timeout 60s</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>Controls the default timeout value used in TCP/unix-domain socket object's <a href="#tcpsock:send">send</a> method and can be overridden by the <a href="#tcpsock:settimeout">settimeout</a> method.
</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=32" title="Edit section: lua socket send lowat">edit</a>]</span> <span class="mw-headline" id="lua_socket_send_lowat"> lua_socket_send_lowat </span></h2>
<p><b>syntax:</b> <i>lua_socket_send_lowat &lt;size&gt;</i>
</p><p><b>default:</b> <i>lua_socket_send_lowat 0</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>Controls the <code>lowat</code> (low water) value for the cosocket send buffer.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=33" title="Edit section: lua socket read timeout">edit</a>]</span> <span class="mw-headline" id="lua_socket_read_timeout"> lua_socket_read_timeout </span></h2>
<p><b>syntax:</b> <i>lua_socket_read_timeout &lt;time&gt;</i>
</p><p><b>default:</b> <i>lua_socket_read_timeout 60s</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p><b>phase:</b> <i>depends on usage</i>
</p><p>This directive controls the default timeout value used in TCP/unix-domain socket object's <a href="#tcpsock:receive">receive</a> method and iterator functions returned by the <a href="#tcpsock:receiveuntil">receiveuntil</a> method. This setting can be overridden by the <a href="#tcpsock:settimeout">settimeout</a> method.
</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=34" title="Edit section: lua socket buffer size">edit</a>]</span> <span class="mw-headline" id="lua_socket_buffer_size"> lua_socket_buffer_size </span></h2>
<p><b>syntax:</b> <i>lua_socket_buffer_size &lt;size&gt;</i>
</p><p><b>default:</b> <i>lua_socket_buffer_size 4k/8k</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>Specifies the buffer size used by cosocket reading operations.
</p><p>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=35" title="Edit section: lua socket pool size">edit</a>]</span> <span class="mw-headline" id="lua_socket_pool_size"> lua_socket_pool_size </span></h2>
<p><b>syntax:</b> <i>lua_socket_pool_size &lt;size&gt;</i>
</p><p><b>default:</b> <i>lua_socket_pool_size 30</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).
</p><p>Default to 30 connections for every pool.
</p><p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
</p><p>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=36" title="Edit section: lua socket keepalive timeout">edit</a>]</span> <span class="mw-headline" id="lua_socket_keepalive_timeout"> lua_socket_keepalive_timeout </span></h2>
<p><b>syntax:</b> <i>lua_socket_keepalive_timeout &lt;time&gt;</i>
</p><p><b>default:</b> <i>lua_socket_keepalive_timeout 60s</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' <a href="#tcpsock:setkeepalive">setkeepalive</a> method.
</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.
</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=37" title="Edit section: lua socket log errors">edit</a>]</span> <span class="mw-headline" id="lua_socket_log_errors"> lua_socket_log_errors </span></h2>
<p><b>syntax:</b> <i>lua_socket_log_errors on|off</i>
</p><p><b>default:</b> <i>lua_socket_log_errors on</i>
</p><p><b>context:</b> <i>http, server, location</i>
</p><p>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).
</p><p>This directive was first introduced in the <code>v0.5.13</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=38" title="Edit section: lua http10 buffering">edit</a>]</span> <span class="mw-headline" id="lua_http10_buffering"> lua_http10_buffering </span></h2>
<p><b>syntax:</b> <i>lua_http10_buffering on|off</i>
</p><p><b>default:</b> <i>lua_http10_buffering on</i>
</p><p><b>context:</b> <i>http, server, location, location-if</i>
</p><p>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper <code>Content-Length</code> response header.
</p><p>If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href="#ngx.send_headers">ngx.send_headers</a> or implicitly via the first <a href="#ngx.say">ngx.say</a> or <a href="#ngx.print">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.
</p><p>To output very large response data in a streaming fashion (via the <a href="#ngx.flush">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.
</p><p>This directive is turned <code>on</code> by default.
</p><p>This directive was first introduced in the <code>v0.5.0rc19</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=39" title="Edit section: rewrite by lua no postpone">edit</a>]</span> <span class="mw-headline" id="rewrite_by_lua_no_postpone"> rewrite_by_lua_no_postpone </span></h2>
<p><b>syntax:</b> <i>rewrite_by_lua_no_postpone on|off</i>
</p><p><b>default:</b> <i>rewrite_by_lua_no_postpone off</i>
</p><p><b>context:</b> <i>http</i>
</p><p>Controls whether or not to disable postponing <a href="#rewrite_by_lua">rewrite_by_lua</a> and <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.
</p><p>This directive was first introduced in the <code>v0.5.0rc29</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=40" title="Edit section: lua transform underscores in response headers">edit</a>]</span> <span class="mw-headline" id="lua_transform_underscores_in_response_headers"> lua_transform_underscores_in_response_headers </span></h2>
<p><b>syntax:</b> <i>lua_transform_underscores_in_response_headers on|off</i>
</p><p><b>default:</b> <i>lua_transform_underscores_in_response_headers on</i>
</p><p><b>context:</b> <i>http, server, location, location-if</i>
</p><p>Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href="#ngx.header.HEADER">ngx.header.HEADER</a> API to hypens (<code>-</code>).
</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=41" title="Edit section: lua check client abort">edit</a>]</span> <span class="mw-headline" id="lua_check_client_abort"> lua_check_client_abort </span></h2>
<p><b>syntax:</b> <i>lua_check_client_abort on|off</i>
</p><p><b>default:</b> <i>lua_check_client_abort off</i>
</p><p><b>context:</b> <i>http, server, location, location-if</i>
</p><p>This directive controls whether to check for premature client connection abortion.
</p><p>When this directive is turned on, the ngx_lua module will monitor the premature connection close event on the downstream connections. And when there is such an event, it will call the user Lua function callback (registered by <a href="#ngx.on_abort">ngx.on_abort</a>) or just stop and clean up all the Lua "light threads" running in the current request's request handler when there is no user callback function registered.
</p><p>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href="#ngx.req.socket">ngx.req.socket</a>, then ngx_lua will neither stop all the running "light threads" nor call the user callback (if <a href="#ngx.on_abort">ngx.on_abort</a> has been called). Instead, the reading operation on <a href="#ngx.req.socket">ngx.req.socket</a> will just return the error message "client aborted" as the second return value (the first return value is surely <code>nil</code>).
</p><p>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a rel="nofollow" class="external text" href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">TCP keepalive</a> support in your system's TCP stack implementation in order to detect "half-open" TCP connections in time.
</p><p>For example, on Linux, you can configure the standard <a href="/HttpCoreModule#listen" title="HttpCoreModule">listen</a> directive in your <code>nginx.conf</code> file like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#listen"><span class="kw3">listen</span></a> <span class="nu0">80</span> so_keepalive<span class="sy0">=</span>2s:2s:<span class="nu0">8</span><span class="sy0">;</span></pre></div></div>
<p>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:
</p>
<pre>   # sysctl net.inet.tcp.keepintvl=2000
   # sysctl net.inet.tcp.keepidle=2000
</pre>
<p>This directive was first introduced in the <code>v0.7.4</code> release.
</p><p>See also <a href="#ngx.on_abort">ngx.on_abort</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=42" title="Edit section: lua max pending timers">edit</a>]</span> <span class="mw-headline" id="lua_max_pending_timers"> lua_max_pending_timers </span></h2>
<p><b>syntax:</b> <i>lua_max_pending_timers &lt;count&gt;</i>
</p><p><b>default:</b> <i>lua_max_pending_timers 1024</i>
</p><p><b>context:</b> <i>http</i>
</p><p>Controls the maximum number of pending timers allowed.
</p><p>Pending timers are those timers that have not expired yet.
</p><p>When exceeding this limit, the <a href="#ngx.timer.at">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string "too many pending timers".
</p><p>This directive was first introduced in the <code>v0.8.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=43" title="Edit section: lua max running timers">edit</a>]</span> <span class="mw-headline" id="lua_max_running_timers"> lua_max_running_timers </span></h2>
<p><b>syntax:</b> <i>lua_max_running_timers &lt;count&gt;</i>
</p><p><b>default:</b> <i>lua_max_running_timers 256</i>
</p><p><b>context:</b> <i>http</i>
</p><p>Controls the maximum number of "running timers" allowed.
</p><p>Running timers are those timers whose user callback functions are still running.
</p><p>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message "N lua_max_running_timers are not enough" where "N" is the current value of this directive.
</p><p>This directive was first introduced in the <code>v0.8.0</code> release.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=44" title="Edit section: Nginx API for Lua">edit</a>]</span> <span class="mw-headline" id="Nginx_API_for_Lua"> Nginx API for Lua </span></h1>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=45" title="Edit section: Introduction">edit</a>]</span> <span class="mw-headline" id="Introduction"> Introduction </span></h2>
<p>The various <code>*_by_lua</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.
</p><p>The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.
</p><p>The packages can be introduced into external Lua modules like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> say <span class="sy0">=</span> ngx.say
&nbsp;
    <span class="kw1">local</span> _M <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="kw1">function</span> _M.foo<span class="br0">(</span>a<span class="br0">)</span>
        say<span class="br0">(</span>a<span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">return</span> _M</pre></div></div>
<p>Use of the <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall">package.seeall</a> flag is strongly discouraged due to its various bad side-effects.
</p><p>It is also possible to directly require the packages in external Lua modules:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> ngx <span class="sy0">=</span> <span class="kw1">require</span> <span class="st0">"ngx"</span>
    <span class="kw1">local</span> ndk <span class="sy0">=</span> <span class="kw1">require</span> <span class="st0">"ndk"</span></pre></div></div>
<p>The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.
</p><p>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the <a href="#ngx.location.capture">ngx.location.capture</a> method and similar) is strongly recommended for maximum performance.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=46" title="Edit section: ngx.arg">edit</a>]</span> <span class="mw-headline" id="ngx.arg"> ngx.arg </span></h2>
<p><b>syntax:</b> <i>val = ngx.arg[index]</i>
</p><p><b>context:</b> <i>set_by_lua*, body_filter_by_lua*</i>
</p><p>When this is used in the context of the <a href="#set_by_lua">set_by_lua</a> or <a href="#set_by_lua_file">set_by_lua_file</a> directives, this table is read-only and holds the input arguments to the config directives:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    value <span class="sy0">=</span> ngx.arg<span class="br0">[</span>n<span class="br0">]</span></pre></div></div>
<p>Here is an example
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$a</span> <span class="nu0">32</span><span class="sy0">;</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$b</span> <span class="nu0">56</span><span class="sy0">;</span>
&nbsp;
        set_by_lua <span class="re0">$res</span>
            <span class="st0">'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'</span>
            <span class="re0">$a</span> <span class="re0">$b</span><span class="sy0">;</span>
&nbsp;
        echo <span class="re0">$sum</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.
</p><p>When this table is used in the context of <a href="#body_filter_by_lua">body_filter_by_lua</a> or <a href="#body_filter_by_lua_file">body_filter_by_lua_file</a>, the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the "eof" flag indicating the end of the whole output data stream.
</p><p>The data chunk and "eof" flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=47" title="Edit section: ngx.var.VARIABLE">edit</a>]</span> <span class="mw-headline" id="ngx.var.VARIABLE"> ngx.var.VARIABLE </span></h2>
<p><b>syntax:</b> <i>ngx.var.VAR_NAME</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</i>
</p><p>Read and write Nginx variable values.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    value <span class="sy0">=</span> ngx.var.some_nginx_variable_name
    ngx.var.some_nginx_variable_name <span class="sy0">=</span> value</pre></div></div>
<p>Note that only already defined nginx variables can be written to.
For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$my_var</span> <span class="st0">''</span><span class="sy0">;</span> <span class="co1"># this line is required to create $my_var at config time</span>
        content_by_lua <span class="st0">'
            ngx.var.my_var = 123;
            ...
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>That is, nginx variables cannot be created on-the-fly.
</p><p>Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value,
some are not, like <code>$arg_PARAMETER</code>.
</p><p>Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this
interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.
</p><p>Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable. 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.var.args <span class="sy0">=</span> <span class="kw1">nil</span></pre></div></div>
<p><b>WARNING</b> When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> val <span class="sy0">=</span> ngx.var.some_var
    <span class="co1">--- use the val repeatedly later</span></pre></div></div>
<p>to prevent (temporary) memory leaking within the current request's lifetime.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=48" title="Edit section: Core constants">edit</a>]</span> <span class="mw-headline" id="Core_constants"> Core constants </span></h2>
<p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*</i>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">  ngx.OK <span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>
  ngx.ERROR <span class="br0">(</span>-<span class="nu0">1</span><span class="br0">)</span>
  ngx.AGAIN <span class="br0">(</span>-<span class="nu0">2</span><span class="br0">)</span>
  ngx.DONE <span class="br0">(</span>-<span class="nu0">4</span><span class="br0">)</span>
  ngx.DECLINED <span class="br0">(</span>-<span class="nu0">5</span><span class="br0">)</span></pre></div></div>
<p>Note that only three of these constants are utilized by the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a> (i.e., <a href="#ngx.exit">ngx.exit</a> accepts <code>NGX_OK</code>, <code>NGX_ERROR</code>, and <code>NGX_DECLINED</code> as input).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">  ngx.null</pre></div></div>
<p>The <code>ngx.null</code> constant is a <code>NULL</code> light userdata usually used to represent nil values in Lua tables etc and is similar to the <a rel="nofollow" class="external text" href="http://www.kyne.com.au/~mark/software/lua-cjson.php">lua-cjson</a> library's <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.
</p><p>The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=49" title="Edit section: HTTP method constants">edit</a>]</span> <span class="mw-headline" id="HTTP_method_constants"> HTTP method constants </span></h2>
<p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*</i>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
  ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
  ngx.HTTP_MKCOL     (added in the v0.8.2 release)
  ngx.HTTP_COPY      (added in the v0.8.2 release)
  ngx.HTTP_MOVE      (added in the v0.8.2 release)
  ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
  ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
  ngx.HTTP_LOCK      (added in the v0.8.2 release)
  ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
  ngx.HTTP_PATCH     (added in the v0.8.2 release)
  ngx.HTTP_TRACE     (added in the v0.8.2 release)</pre></div></div>
<p>These constants are usually used in <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> method calls.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=50" title="Edit section: HTTP status constants">edit</a>]</span> <span class="mw-headline" id="HTTP_status_constants"> HTTP status constants </span></h2>
<p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*</i>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">  value <span class="sy0">=</span> ngx.HTTP_OK <span class="br0">(</span><span class="nu0">200</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_CREATED <span class="br0">(</span><span class="nu0">201</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_SPECIAL_RESPONSE <span class="br0">(</span><span class="nu0">300</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_MOVED_PERMANENTLY <span class="br0">(</span><span class="nu0">301</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_MOVED_TEMPORARILY <span class="br0">(</span><span class="nu0">302</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_SEE_OTHER <span class="br0">(</span><span class="nu0">303</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_NOT_MODIFIED <span class="br0">(</span><span class="nu0">304</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_BAD_REQUEST <span class="br0">(</span><span class="nu0">400</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_UNAUTHORIZED <span class="br0">(</span><span class="nu0">401</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_FORBIDDEN <span class="br0">(</span><span class="nu0">403</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_NOT_FOUND <span class="br0">(</span><span class="nu0">404</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_NOT_ALLOWED <span class="br0">(</span><span class="nu0">405</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_GONE <span class="br0">(</span><span class="nu0">410</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_INTERNAL_SERVER_ERROR <span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_METHOD_NOT_IMPLEMENTED <span class="br0">(</span><span class="nu0">501</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_SERVICE_UNAVAILABLE <span class="br0">(</span><span class="nu0">503</span><span class="br0">)</span>
  value <span class="sy0">=</span> ngx.HTTP_GATEWAY_TIMEOUT <span class="br0">(</span><span class="nu0">504</span><span class="br0">)</span> <span class="br0">(</span>first added in the v0.3.1rc38 release<span class="br0">)</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=51" title="Edit section: Nginx log level constants">edit</a>]</span> <span class="mw-headline" id="Nginx_log_level_constants"> Nginx log level constants </span></h2>
<p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*</i>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">  ngx.STDERR
  ngx.EMERG
  ngx.ALERT
  ngx.CRIT
  ngx.ERR
  ngx.WARN
  ngx.NOTICE
  ngx.INFO
  ngx.DEBUG</pre></div></div>
<p>These constants are usually used by the <a href="#ngx.log">ngx.log</a> method.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=52" title="Edit section: print">edit</a>]</span> <span class="mw-headline" id="print"> print </span></h2>
<p><b>syntax:</b> <i>print(...)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*</i>
</p><p>Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.
</p><p>It is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.NOTICE, ...<span class="br0">)</span></pre></div></div>
<p>Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> strings while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> strings. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=53" title="Edit section: ngx.ctx">edit</a>]</span> <span class="mw-headline" id="ngx.ctx"> ngx.ctx </span></h2>
<p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*</i>
</p><p>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables). 
</p><p>Consider the following example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        rewrite_by_lua <span class="st0">'
            ngx.say("foo = ", ngx.ctx.foo)
            ngx.ctx.foo = 76
        '</span><span class="sy0">;</span>
        access_by_lua <span class="st0">'
            ngx.ctx.foo = ngx.ctx.foo + 3
        '</span><span class="sy0">;</span>
        content_by_lua <span class="st0">'
            ngx.say(ngx.ctx.foo)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then <code>GET /test</code> will yield the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo = nil
    <span class="nu0">79</span></pre></div></div>
<p>That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.
</p><p>Every request, including subrequests, has its own copy of the table. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /sub <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.say("sub pre: ", ngx.ctx.blah)
            ngx.ctx.blah = 32
            ngx.say("sub post: ", ngx.ctx.blah)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /main <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.ctx.blah = 73
            ngx.say("main pre: ", ngx.ctx.blah)
            local res = ngx.location.capture("/sub")
            ngx.print(res.body)
            ngx.say("main post: ", ngx.ctx.blah)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then <code>GET /main</code> will give the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    main pre: <span class="nu0">73</span>
    sub pre: nil
    sub post: <span class="nu0">32</span>
    main post: <span class="nu0">73</span></pre></div></div>
<p>Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.
</p><p>Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code> table. For instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /new <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.say(ngx.ctx.foo)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /orig <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.ctx.foo = "hello"
            ngx.exec("/new")
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then <code>GET /orig</code> will give
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    nil</pre></div></div>
<p>rather than the original <code>"hello"</code> value.
</p><p>Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.
</p><p>Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.ctx <span class="sy0">=</span> <span class="br0">{</span> foo <span class="sy0">=</span> <span class="nu0">32</span>, bar <span class="sy0">=</span> <span class="nu0">54</span> <span class="br0">}</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=54" title="Edit section: ngx.location.capture">edit</a>]</span> <span class="mw-headline" id="ngx.location.capture"> ngx.location.capture </span></h2>
<p><b>syntax:</b> <i>res = ngx.location.capture(uri, options?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Issue a synchronous but still non-blocking <i>Nginx Subrequest</i> using <code>uri</code>.
</p><p>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or <i>any</i> other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>,
<code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.
</p><p>Also note that subrequests just mimic the HTTP interface but there is <i>no</i> extra HTTP/TCP traffic <i>nor</i> IPC involved. Everything works internally, efficiently, on the C level.
</p><p>Subrequests are completely different from HTTP 301/302 redirection (via <a href="#ngx.redirect">ngx.redirect</a>) and internal redirection (via <a href="#ngx.exec">ngx.exec</a>).
</p><p>You should always read the request body (by either calling <a href="#ngx.req.read_body">ngx.req.read_body</a> or configuring <a href="#lua_need_request_body">lua_need_request_body</a> on) before initiating a subrequest.
</p><p>Here is a basic example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    res <span class="sy0">=</span> ngx.location.capture<span class="br0">(</span>uri<span class="br0">)</span></pre></div></div>
<p>Returns a Lua table with three slots (<code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>).
</p><p><code>res.status</code> holds the response status code for the subrequest response.
</p><p><code>res.header</code> holds all the response headers of the
subrequest and it is a normal Lua table. For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear. For instance, if the subrequest response headers contain the following
lines:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    Set-Cookie: <span class="re2">a</span>=<span class="nu0">3</span>
    Set-Cookie: <span class="re2">foo</span>=bar
    Set-Cookie: <span class="re2">baz</span>=blah</pre></div></div>
<p>Then <code>res.header["Set-Cookie"]</code> will be evaluated to the table value
<code>{"a=3", "foo=bar", "baz=blah"}</code>.
</p><p><code>res.body</code> holds the subrequest's response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data.
</p><p>URI query strings can be concatenated to URI itself, for instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    res <span class="sy0">=</span> ngx.location.capture<span class="br0">(</span><span class="st0">'/foo/bar?a=3&amp;b=4'</span><span class="br0">)</span></pre></div></div>
<p>Named locations like <code>@foo</code> are not allowed due to a limitation in
the nginx core. Use normal locations combined with the <code>internal</code> directive to
prepare internal-only locations.
</p><p>An optional option table can be fed as the second
argument, which supports the options:
</p>
<ul><li> <code>method</code>
</li></ul>
<dl><dd> specify the subrequest's request method, which only accepts constants like <code>ngx.HTTP_POST</code>.
</dd></dl>
<ul><li> <code>body</code>
</li></ul>
<dl><dd> specify the subrequest's request body (string value only).
</dd></dl>
<ul><li> <code>args</code>
</li></ul>
<dl><dd> specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
</dd></dl>
<ul><li> <code>ctx</code>
</li></ul>
<dl><dd> specify a Lua table to be the <a href="#ngx.ctx">ngx.ctx</a> table for the subrequest. It can be the current request's <a href="#ngx.ctx">ngx.ctx</a> table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the <code>v0.3.1rc25</code> release.
</dd></dl>
<ul><li> <code>vars</code>
</li></ul>
<dl><dd> take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the <code>v0.3.1rc31</code> release.
</dd></dl>
<ul><li> <code>copy_all_vars</code>
</li></ul>
<dl><dd> specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.
</dd></dl>
<ul><li> <code>share_all_vars</code>
</li></ul>
<dl><dd> specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request.
</dd></dl>
<ul><li> <code>always_forward_body</code>
</li></ul>
<dl><dd> when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. The request body read by either <a href="#ngx.req.read_body">ngx.req.read_body()</a> or <a href="#lua_need_request_body">lua_need_request_body on</a> will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is <code>false</code> and when the <code>body</code> option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the <code>PUT</code> or <code>POST</code> request method.
</dd></dl>
<p>Issuing a POST subrequest, for example, can be done as follows
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    res <span class="sy0">=</span> ngx.location.capture<span class="br0">(</span>
        <span class="st0">'/foo/bar'</span>,
        <span class="br0">{</span> method <span class="sy0">=</span> ngx.HTTP_POST, body <span class="sy0">=</span> <span class="st0">'hello, world'</span> <span class="br0">}</span>
    <span class="br0">)</span></pre></div></div>
<p>See HTTP method constants methods other than POST.
The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.
</p><p>The <code>args</code> option can specify extra URI arguments, for instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.location.capture<span class="br0">(</span><span class="st0">'/foo?a=1'</span>,
        <span class="br0">{</span> args <span class="sy0">=</span> <span class="br0">{</span> b <span class="sy0">=</span> <span class="nu0">3</span>, c <span class="sy0">=</span> <span class="st0">':'</span> <span class="br0">}</span> <span class="br0">}</span>
    <span class="br0">)</span></pre></div></div>
<p>is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.location.capture<span class="br0">(</span><span class="st0">'/foo?a=1&amp;b=3&amp;c=%3a'</span><span class="br0">)</span></pre></div></div>
<p>that is, this method will escape argument keys and values according to URI rules and
concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the <a href="#ngx.encode_args">ngx.encode_args</a> method.
</p><p>The <code>args</code> option can also take plain query strings:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.location.capture<span class="br0">(</span><span class="st0">'/foo?a=1'</span>,
        <span class="br0">{</span> args <span class="sy0">=</span> <span class="st0">'b=3&amp;c=%3a'</span> <span class="br0">}</span> <span class="br0">}</span>
    <span class="br0">)</span></pre></div></div>
<p>This is functionally identical to the previous examples.
</p><p>The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. 
If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.
</p><p>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.
</p><p>This option is set to <code>false</code> by default
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /other <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$dog</span> <span class="st0">"$dog world"</span><span class="sy0">;</span>
        echo <span class="st0">"$uri dog: $dog"</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$dog</span> <span class="st0">'hello'</span><span class="sy0">;</span>
        content_by_lua <span class="st0">'
            res = ngx.location.capture("/other",
                { share_all_vars = true });
&nbsp;
            ngx.print(res.body)
            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Accessing location <code>/lua</code> gives
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    /other dog: hello world
    /lua: hello world</pre></div></div>
<p>The <code>copy_all_vars</code> option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /other <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$dog</span> <span class="st0">"$dog world"</span><span class="sy0">;</span>
        echo <span class="st0">"$uri dog: $dog"</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$dog</span> <span class="st0">'hello'</span><span class="sy0">;</span>
        content_by_lua <span class="st0">'
            res = ngx.location.capture("/other",
                { copy_all_vars = true });
&nbsp;
            ngx.print(res.body)
            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Request <code>GET /lua</code> will give the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    /other dog: hello world
    /lua: hello</pre></div></div>
<p>Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.
</p><p>In addition to the two settings above, it is possible to specify
values for variables in the subrequest using the <code>vars</code> option. These
variables are set after the sharing or copying of variables has been
evaluated, and provides a more efficient method of passing specific
values to a subrequest over encoding them as URL arguments and 
unescaping them in the Nginx config file.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /other <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.say("dog = ", ngx.var.dog)
            ngx.say("cat = ", ngx.var.cat)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$dog</span> <span class="st0">''</span><span class="sy0">;</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$cat</span> <span class="st0">''</span><span class="sy0">;</span>
        content_by_lua <span class="st0">'
            res = ngx.location.capture("/other",
                { vars = { dog = "hello", cat = 32 }});
&nbsp;
            ngx.print(res.body)
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Accessing <code>/lua</code> will yield the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    dog = hello
    cat = 32</pre></div></div>
<p>The <code>ctx</code> option can be used to specify a custom Lua table to serve as the <a href="#ngx.ctx">ngx.ctx</a> table for the subrequest.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /sub <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.ctx.foo = "bar";
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local ctx = {}
            res = ngx.location.capture("/sub", { ctx = ctx })
&nbsp;
            ngx.say(ctx.foo);
            ngx.say(ngx.ctx.foo);
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then request <code>GET /lua</code> gives
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    bar
    nil</pre></div></div>
<p>It is also possible to use this <code>ctx</code> option to share the same <a href="#ngx.ctx">ngx.ctx</a> table between the current (parent) request and the subrequest:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /sub <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.ctx.foo = "bar";
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        content_by_lua <span class="st0">'
            res = ngx.location.capture("/sub", { ctx = ngx.ctx })
            ngx.say(ngx.ctx.foo);
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Request <code>GET /lua</code> yields the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    bar</pre></div></div>
<p>Note that subrequests issued by <a href="#ngx.location.capture">ngx.location.capture</a> inherit all the
request headers of the current request by default and that this may have unexpected side effects on the
subrequest responses. For example, when using the standard <code>ngx_proxy</code> module to serve
subrequests, an "Accept-Encoding: gzip" header in the main request may result
in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting 
<a href="/HttpProxyModule#proxy_pass_request_headers" title="HttpProxyModule">proxy_pass_request_headers</a> to <code>off</code> in subrequest locations.
</p><p>When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code> subrequests will inherit the request bodies of the parent request (if any).
</p><p>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    [error] 13983#0: *1 subrequests cycle while processing "/uri"</pre></div></div>
<p>The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.
</p><p>Please also refer to restrictions on capturing locations configured by <a href="#Locations_Configured_by_Subrequest_Directives_of_Other_Modules">subrequest directives of other modules</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=55" title="Edit section: ngx.location.capture multi">edit</a>]</span> <span class="mw-headline" id="ngx.location.capture_multi"> ngx.location.capture_multi </span></h2>
<p><b>syntax:</b> <i>res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Just like <a href="#ngx.location.capture">ngx.location.capture</a>, but supports multiple subrequests running in parallel.
</p><p>This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    res1, res2, res3 <span class="sy0">=</span> ngx.location.capture_multi<span class="br0">{</span>
        <span class="br0">{</span> <span class="st0">"/foo"</span>, <span class="br0">{</span> args <span class="sy0">=</span> <span class="st0">"a=3&amp;b=4"</span> <span class="br0">}</span> <span class="br0">}</span>,
        <span class="br0">{</span> <span class="st0">"/bar"</span> <span class="br0">}</span>,
        <span class="br0">{</span> <span class="st0">"/baz"</span>, <span class="br0">{</span> method <span class="sy0">=</span> ngx.HTTP_POST, body <span class="sy0">=</span> <span class="st0">"hello"</span> <span class="br0">}</span> <span class="br0">}</span>,
    <span class="br0">}</span>
&nbsp;
    <span class="kw1">if</span> res1.status <span class="sy0">==</span> ngx.HTTP_OK <span class="kw1">then</span>
        ...
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">if</span> res2.body <span class="sy0">==</span> <span class="st0">"BLAH"</span> <span class="kw1">then</span>
        ...
    <span class="kw1">end</span></pre></div></div>
<p>This function will not return until all the subrequests terminate.
The total latency is the longest latency of the individual subrequests rather than the sum.
</p><p>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- construct the requests table</span>
    <span class="kw1">local</span> reqs <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span>
    <span class="kw1">table.insert</span><span class="br0">(</span>reqs, <span class="br0">{</span> <span class="st0">"/mysql"</span> <span class="br0">}</span><span class="br0">)</span>
    <span class="kw1">table.insert</span><span class="br0">(</span>reqs, <span class="br0">{</span> <span class="st0">"/postgres"</span> <span class="br0">}</span><span class="br0">)</span>
    <span class="kw1">table.insert</span><span class="br0">(</span>reqs, <span class="br0">{</span> <span class="st0">"/redis"</span> <span class="br0">}</span><span class="br0">)</span>
    <span class="kw1">table.insert</span><span class="br0">(</span>reqs, <span class="br0">{</span> <span class="st0">"/memcached"</span> <span class="br0">}</span><span class="br0">)</span>
&nbsp;
    <span class="co1">-- issue all the requests at once and wait until they all return</span>
    <span class="kw1">local</span> resps <span class="sy0">=</span> <span class="br0">{</span> ngx.location.capture_multi<span class="br0">(</span>reqs<span class="br0">)</span> <span class="br0">}</span>
&nbsp;
    <span class="co1">-- loop over the responses table</span>
    <span class="kw1">for</span> i, resp <span class="kw1">in</span> <span class="kw1">ipairs</span><span class="br0">(</span>resps<span class="br0">)</span> <span class="kw1">do</span>
        <span class="co1">-- process the response table "resp"</span>
    <span class="kw1">end</span></pre></div></div>
<p>The <a href="#ngx.location.capture">ngx.location.capture</a> function is just a special form
of this function. Logically speaking, the <a href="#ngx.location.capture">ngx.location.capture</a> can be implemented like this
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.location.capture <span class="sy0">=</span>
        <span class="kw1">function</span> <span class="br0">(</span>uri, args<span class="br0">)</span>
            <span class="kw1">return</span> ngx.location.capture_multi<span class="br0">(</span><span class="br0">{</span> <span class="br0">{</span>uri, args<span class="br0">}</span> <span class="br0">}</span><span class="br0">)</span>
        <span class="kw1">end</span></pre></div></div>
<p>Please also refer to restrictions on capturing locations configured by <a href="#Locations_Configured_by_Subrequest_Directives_of_Other_Modules">subrequest directives of other modules</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=56" title="Edit section: ngx.status">edit</a>]</span> <span class="mw-headline" id="ngx.status"> ngx.status </span></h2>
<p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*</i>
</p><p>Read and write the current request's response status. This should be called
before sending out the response headers.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.status <span class="sy0">=</span> ngx.HTTP_CREATED
    status <span class="sy0">=</span> ngx.status</pre></div></div>
<p>Setting <code>ngx.status</code> after the response header is sent out has no effect but leaving an error message in your nginx's error log file:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    attempt to set ngx.status after sending out response headers</pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=57" title="Edit section: ngx.header.HEADER">edit</a>]</span> <span class="mw-headline" id="ngx.header.HEADER"> ngx.header.HEADER </span></h2>
<p><b>syntax:</b> <i>ngx.header.HEADER = VALUE</i>
</p><p><b>syntax:</b> <i>value = ngx.header.HEADER</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*</i>
</p><p>Set, add to, or clear the current request's <code>HEADER</code> response header that is to be sent.
</p><p>Underscores (<code>_</code>) in the header names will be replaced by hyphens (<code>-</code>) by default. This transformation can be turned off via the <a href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a> directive.
</p><p>The header names are matched case-insensitively.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- equivalent to ngx.header["Content-Type"] = 'text/plain'</span>
    ngx.header.content_type <span class="sy0">=</span> <span class="st0">'text/plain'</span><span class="sy0">;</span>
&nbsp;
    ngx.header<span class="br0">[</span><span class="st0">"X-My-Header"</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">'blah blah'</span><span class="sy0">;</span></pre></div></div>
<p>Multi-value headers can be set this way:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.header<span class="br0">[</span><span class="st0">'Set-Cookie'</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="st0">'a=32; path=/'</span>, <span class="st0">'b=4; path=/'</span><span class="br0">}</span></pre></div></div>
<p>will yield
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    Set-Cookie: <span class="re2">a</span>=<span class="nu0">32</span>; <span class="re2">path</span>=<span class="sy0">/</span>
    Set-Cookie: <span class="re2">b</span>=<span class="nu0">4</span>; <span class="re2">path</span>=<span class="sy0">/</span></pre></div></div>
<p>in the response headers. 
</p><p>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code> that only accept a single value).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.header.content_type <span class="sy0">=</span> <span class="br0">{</span><span class="st0">'a'</span>, <span class="st0">'b'</span><span class="br0">}</span></pre></div></div>
<p>is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.header.content_type <span class="sy0">=</span> <span class="st0">'b'</span></pre></div></div>
<p>Setting a slot to <code>nil</code> effectively removes it from the response headers:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.header<span class="br0">[</span><span class="st0">"X-My-Header"</span><span class="br0">]</span> <span class="sy0">=</span> <span class="kw1">nil</span><span class="sy0">;</span></pre></div></div>
<p>The same applies to assigning an empty table:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.header<span class="br0">[</span><span class="st0">"X-My-Header"</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with <a href="#ngx.send_headers">ngx.send_headers</a> or implicitly with <a href="#ngx.print">ngx.print</a> and similar) will throw out a Lua exception.
</p><p>Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>. 
</p><p>Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.
</p><p>This is particularly useful in the context of <a href="#header_filter_by_lua">header_filter_by_lua</a> and <a href="#header_filter_by_lua_file">header_filter_by_lua_file</a>, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="re0">$footer</span> <span class="st0">''</span><span class="sy0">;</span>
&nbsp;
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://some-backend<span class="sy0">;</span>
&nbsp;
        header_filter_by_lua <span class="st0">'
            if ngx.header["X-My-Header"] == "blah" then
                ngx.var.footer = "some value"
            end
        '</span><span class="sy0">;</span>
&nbsp;
        echo_after_body <span class="re0">$footer</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    Foo: bar
    Foo: baz</pre></div></div>
<p>will result in
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="br0">{</span><span class="st0">"bar"</span>, <span class="st0">"baz"</span><span class="br0">}</span></pre></div></div>
<p>to be returned when reading <code>ngx.header.Foo</code>.
</p><p>Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code> function.
</p><p>For reading <i>request</i> headers, use the <a href="#ngx.req.get_headers">ngx.req.get_headers</a> function instead.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=58" title="Edit section: ngx.req.start time">edit</a>]</span> <span class="mw-headline" id="ngx.req.start_time"> ngx.req.start_time </span></h2>
<p><b>syntax:</b> <i>secs = ngx.req.start_time()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</i>
</p><p>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.
</p><p>The following example emulates the <code>$request_time</code> variable value (provided by <a href="/HttpLogModule" title="HttpLogModule">HttpLogModule</a>) in pure Lua:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> request_time <span class="sy0">=</span> ngx.now<span class="br0">(</span><span class="br0">)</span> - ngx.req.start_time<span class="br0">(</span><span class="br0">)</span></pre></div></div>
<p>This function was first introduced in the <code>v0.7.7</code> release.
</p><p>See also <a href="#ngx.now">ngx.now</a> and <a href="#ngx.update_time">ngx.update_time</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=59" title="Edit section: ngx.req.http version">edit</a>]</span> <span class="mw-headline" id="ngx.req.http_version"> ngx.req.http_version </span></h2>
<p><b>syntax:</b> <i>num = ngx.req.http_version()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</i>
</p><p>Returns the HTTP version number for the current request as a Lua number.
</p><p>Current possible values are 1.0, 1.1, and 0.9. Returns <code>nil</code> for unrecognized values.
</p><p>This method was first introduced in the <code>v0.7.17</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=60" title="Edit section: ngx.req.raw header">edit</a>]</span> <span class="mw-headline" id="ngx.req.raw_header"> ngx.req.raw_header </span></h2>
<p><b>syntax:</b> <i>str = ngx.req.raw_header(no_request_line?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</i>
</p><p>Returns the original raw HTTP protocol header received by the Nginx server.
</p><p>By default, the request line and trailing <code>CR LF</code> terminator will also be included. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.<span class="kw1">print</span><span class="br0">(</span>ngx.req.raw_header<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span></pre></div></div>
<p>gives something like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    GET /t HTTP/1.1
    Host: localhost
    Connection: close
    Foo: bar</pre></div></div>
<p>You can specify the optional
<code>no_request_line</code> argument as a <code>true</code> value to exclude the request line from the result. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.<span class="kw1">print</span><span class="br0">(</span>ngx.req.raw_header<span class="br0">(</span><span class="kw1">true</span><span class="br0">)</span><span class="br0">)</span></pre></div></div>
<p>outputs something like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    Host: localhost
    Connection: close
    Foo: bar</pre></div></div>
<p>This method was first introduced in the <code>v0.7.17</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=61" title="Edit section: ngx.req.get method">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_method"> ngx.req.get_method </span></h2>
<p><b>syntax:</b> <i>method_name = ngx.req.get_method()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</i>
</p><p>Retrieves the current request's request method name. Strings like <code>"GET"</code> and <code>"POST"</code> are returned instead of numerical <a href="#HTTP_method_constants">method constants</a>.
</p><p>If the current request is an Nginx subrequest, then the subrequest's method name will be returned.
</p><p>This method was first introduced in the <code>v0.5.6</code> release.
</p><p>See also <a href="#ngx.req.set_method">ngx.req.set_method</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=62" title="Edit section: ngx.req.set method">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_method"> ngx.req.set_method </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_method(method_id)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</i>
</p><p>Overrides the current request's request method with the <code>request_id</code> argument. Currently only numerical <a href="#HTTP_method_constants">method constants</a> are supported, like <code>ngx.HTTP_POST</code> and <code>ngx.HTTP_GET</code>.
</p><p>If the current request is an Nginx subrequest, then the subrequest's method will be overridden.
</p><p>This method was first introduced in the <code>v0.5.6</code> release.
</p><p>See also <a href="#ngx.req.get_method">ngx.req.get_method</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=63" title="Edit section: ngx.req.set uri">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_uri"> ngx.req.set_uri </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_uri(uri, jump?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</i>
</p><p>Rewrite the current request's (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.
</p><p>The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as <a href="/HttpRewriteModule" title="HttpRewriteModule">HttpRewriteModule</a>'s <a href="/HttpRewriteModule#rewrite" title="HttpRewriteModule">rewrite</a> directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.
</p><p>Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.
</p><p>For example, the following nginx config snippet
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /foo last<span class="sy0">;</span></pre></div></div>
<p>can be coded in Lua like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri<span class="br0">(</span><span class="st0">"/foo"</span>, <span class="kw1">true</span><span class="br0">)</span></pre></div></div>
<p>Similarly, Nginx config
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /foo <a href="/NginxHttpRewriteModule#break"><span class="kw22">break</span></a><span class="sy0">;</span></pre></div></div>
<p>can be coded in Lua as
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri<span class="br0">(</span><span class="st0">"/foo"</span>, <span class="kw1">false</span><span class="br0">)</span></pre></div></div>
<p>or equivalently,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri<span class="br0">(</span><span class="st0">"/foo"</span><span class="br0">)</span></pre></div></div>
<p>The <code>jump</code> can only be set to <code>true</code> in <a href="#rewrite_by_lua">rewrite_by_lua</a> and <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a>. Use of jump in other contexts is prohibited and will throw out a Lua exception.
</p><p>A more sophisticated example involving regex substitutions is as follows
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        rewrite_by_lua <span class="st0">'
            local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "$1", "o")
            ngx.req.set_uri(uri)
        '</span><span class="sy0">;</span>
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://my_backend<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>which is functionally equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^/test/<span class="br0">(</span>.*<span class="br0">)</span> /$<span class="nu0">1</span> <a href="/NginxHttpRewriteModule#break"><span class="kw22">break</span></a><span class="sy0">;</span>
        <a href="/NginxHttpProxyModule#proxy_pass"><span class="kw21">proxy_pass</span></a> <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://my_backend<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Note that it is not possible to use this interface to rewrite URI arguments and that <a href="#ngx.req.set_uri_args">ngx.req.set_uri_args</a> should be used for this instead. For instance, Nginx config
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /foo?a<span class="sy0">=</span><span class="nu0">3</span>? last<span class="sy0">;</span></pre></div></div>
<p>can be coded as
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    ngx.req.set_uri_args<span class="br0">(</span><span class="st0">"a=3"</span><span class="br0">)</span>
    ngx.req.set_uri<span class="br0">(</span><span class="st0">"/foo"</span>, true<span class="br0">)</span></pre></div></div>
<p>or
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    ngx.req.set_uri_args<span class="br0">(</span><span class="br0">{</span>a <span class="sy0">=</span> <span class="nu0">3</span><span class="br0">}</span><span class="br0">)</span>
    ngx.req.set_uri<span class="br0">(</span><span class="st0">"/foo"</span>, true<span class="br0">)</span></pre></div></div>
<p>This interface was first introduced in the <code>v0.3.1rc14</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=64" title="Edit section: ngx.req.set uri args">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_uri_args"> ngx.req.set_uri_args </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_uri_args(args)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</i>
</p><p>Rewrite the current request's URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri_args<span class="br0">(</span><span class="st0">"a=3&amp;b=hello%20world"</span><span class="br0">)</span></pre></div></div>
<p>or a Lua table holding the query arguments' key-value pairs, as in
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri_args<span class="br0">(</span><span class="br0">{</span> a <span class="sy0">=</span> <span class="nu0">3</span>, b <span class="sy0">=</span> <span class="st0">"hello world"</span> <span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.
</p><p>Multi-value arguments are also supported:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_uri_args<span class="br0">(</span><span class="br0">{</span> a <span class="sy0">=</span> <span class="nu0">3</span>, b <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span> <span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>which will result in a query string like <code>a=3&amp;b=5&amp;b=6</code>.
</p><p>This interface was first introduced in the <code>v0.3.1rc13</code> release.
</p><p>See also <a href="#ngx.req.set_uri">ngx.req.set_uri</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=65" title="Edit section: ngx.req.get uri args">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_uri_args"> ngx.req.get_uri_args </span></h2>
<p><b>syntax:</b> <i>args = ngx.req.get_uri_args(max_args?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*</i>
</p><p>Returns a Lua table holding all the current request URL query arguments.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /test <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local args = ngx.req.get_uri_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then <code>GET /test?foo=bar&amp;bar=baz&amp;bar=blah</code> will yield the response body
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: bar
    bar: baz, blah</pre></div></div>
<p>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.
</p><p>Keys and values are unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    a b: 1a <span class="nu0">2</span></pre></div></div>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: <span class="kw2">true</span>
    bar: <span class="kw2">true</span></pre></div></div>
<p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&amp;bar=</code> will give something like
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: 
    bar:</pre></div></div>
<p>Empty key arguments are discarded. <code>GET /test?=hello&amp;=world</code> will yield an empty output for instance.
</p><p>Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.var.args <span class="sy0">=</span> <span class="st0">"a=3&amp;b=42"</span>
    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_uri_args<span class="br0">(</span><span class="br0">)</span></pre></div></div>
<p>Here the <code>args</code> table will always look like
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="br0">{</span>a <span class="sy0">=</span> <span class="nu0">3</span>, b <span class="sy0">=</span> <span class="nu0">42</span><span class="br0">}</span></pre></div></div>
<p>regardless of the actual request query string.
</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.
</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_uri_args<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span></pre></div></div>
<p>This argument can be set to zero to remove the limit and to process all request arguments received:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_uri_args<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span></pre></div></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=66" title="Edit section: ngx.req.get post args">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_post_args"> ngx.req.get_post_args </span></h2>
<p><b>syntax:</b> <i>args, err = ngx.req.get_post_args(max_args?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*</i>
</p><p>Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call <a href="#ngx.req.read_body">ngx.req.read_body</a> to read the request body first or turn on the <a href="#lua_need_request_body">lua_need_request_body</a> directive to avoid errors.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /test <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.req.read_body()
            local args = ngx.req.get_post_args()
            if not args then
                ngx.say("failed to get post args: ", err)
                return
            end
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Then
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    <span class="co0"># Post request with the body 'foo=bar&amp;bar=baz&amp;bar=blah'</span>
    $ curl <span class="re5">--data</span> <span class="st_h">'foo=bar&amp;bar=baz&amp;bar=blah'</span> localhost<span class="sy0">/</span><span class="kw3">test</span></pre></div></div>
<p>will yield the response body like
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: bar
    bar: baz, blah</pre></div></div>
<p>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.
</p><p>Keys and values will be unescaped according to URI escaping rules.
</p><p>With the settings above,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    <span class="co0"># POST request with body 'a%20b=1%61+2'</span>
    $ curl <span class="re5">-d</span> <span class="st_h">'a%20b=1%61+2'</span> localhost<span class="sy0">/</span><span class="kw3">test</span></pre></div></div>
<p>will yield:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    a b: 1a <span class="nu0">2</span></pre></div></div>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: <span class="kw2">true</span>
    bar: <span class="kw2">true</span></pre></div></div>
<p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&amp;bar=</code> will return something like
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    foo: 
    bar:</pre></div></div>
<p>Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&amp;=world</code> will yield empty outputs for instance.
</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.  
</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_post_args<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span></pre></div></div>
<p>This argument can be set to zero to remove the limit and to process all request arguments received:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_post_args<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span></pre></div></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=67" title="Edit section: ngx.req.get headers">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_headers"> ngx.req.get_headers </span></h2>
<p><b>syntax:</b> <i>headers = ngx.req.get_headers(max_headers?, raw?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*</i>
</p><p>Returns a Lua table holding all the current request headers.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> h <span class="sy0">=</span> ngx.req.get_headers<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">for</span> k, v <span class="kw1">in</span> <span class="kw1">pairs</span><span class="br0">(</span>h<span class="br0">)</span> <span class="kw1">do</span>
        ...
    <span class="kw1">end</span></pre></div></div>
<p>To read an individual header:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.say<span class="br0">(</span><span class="st0">"Host: "</span>, ngx.req.get_headers<span class="br0">(</span><span class="br0">)</span><span class="br0">[</span><span class="st0">"Host"</span><span class="br0">]</span><span class="br0">)</span></pre></div></div>
<p>Note that the <a href="#ngx.var.VARIABLE">ngx.var.HEADER</a> API call, which uses core <a href="/HttpCoreModule#.24http_HEADER" title="HttpCoreModule">$http_HEADER</a> variables, may be more preferable for reading individual request headers.
</p><p>For multiple instances of request headers such as:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    Foo: foo
    Foo: bar
    Foo: baz</pre></div></div>
<p>the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua (array) table such as:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="br0">{</span><span class="st0">"foo"</span>, <span class="st0">"bar"</span>, <span class="st0">"baz"</span><span class="br0">}</span></pre></div></div>
<p>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.  
</p><p>However, the optional <code>max_headers</code> function argument can be used to override this limit:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_headers<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span></pre></div></div>
<p>This argument can be set to zero to remove the limit and to process all request headers received:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_headers<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span></pre></div></div>
<p>Removing the <code>max_headers</code> cap is strongly discouraged.
</p><p>Since the <code>0.6.9</code> release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the <code>raw</code> argument is set to <code>true</code> (default to <code>false</code>).
</p><p>Also, by default, an <code>__index</code> metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header <code>My-Foo-Header</code> is present, then the following invocations will all pick up the value of this header correctly:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.say<span class="br0">(</span>headers.my_foo_header<span class="br0">)</span>
    ngx.say<span class="br0">(</span>headers<span class="br0">[</span><span class="st0">"My-Foo-Header"</span><span class="br0">]</span><span class="br0">)</span>
    ngx.say<span class="br0">(</span>headers<span class="br0">[</span><span class="st0">"my-foo-header"</span><span class="br0">]</span><span class="br0">)</span></pre></div></div>
<p>The <code>__index</code> metamethod will not be added when the <code>raw</code> argument is set to <code>true</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=68" title="Edit section: ngx.req.set header">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_header"> ngx.req.set_header </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_header(header_name, header_value)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua</i>
</p><p>Set the current request's request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.
</p><p>By default, all the subrequests subsequently initiated by <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> will inherit the new header.
</p><p>Here is an example of setting the <code>Content-Length</code> header:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_header<span class="br0">(</span><span class="st0">"Content-Type"</span>, <span class="st0">"text/css"</span><span class="br0">)</span></pre></div></div>
<p>The <code>header_value</code> can take an array list of values,
for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_header<span class="br0">(</span><span class="st0">"Foo"</span>, <span class="br0">{</span><span class="st0">"a"</span>, <span class="st0">"abc"</span><span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>will produce two new request headers:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    Foo: a
    Foo: abc</pre></div></div>
<p>and old <code>Foo</code> headers will be overridden if there is any.
</p><p>When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.set_header<span class="br0">(</span><span class="st0">"X-Foo"</span>, <span class="kw1">nil</span><span class="br0">)</span></pre></div></div>
<p>is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.clear_header<span class="br0">(</span><span class="st0">"X-Foo"</span><span class="br0">)</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=69" title="Edit section: ngx.req.clear header">edit</a>]</span> <span class="mw-headline" id="ngx.req.clear_header"> ngx.req.clear_header </span></h2>
<p><b>syntax:</b> <i>ngx.req.clear_header(header_name)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</i>
</p><p>Clear the current request's request header named <code>header_name</code>. None of the current request's subrequests will be affected.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=70" title="Edit section: ngx.req.read body">edit</a>]</span> <span class="mw-headline" id="ngx.req.read_body"> ngx.req.read_body </span></h2>
<p><b>syntax:</b> <i>ngx.req.read_body()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Reads the client request body synchronously without blocking the Nginx event loop.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.read_body<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.req.get_post_args<span class="br0">(</span><span class="br0">)</span></pre></div></div>
<p>If the request body is already read previously by turning on <a href="#lua_need_request_body">lua_need_request_body</a> or by using other modules, then this function does not run and returns immediately.
</p><p>If the request body has already been explicitly discarded, either by the <a href="#ngx.req.discard_body">ngx.req.discard_body</a> function or other modules, this function does not run and returns immediately.
</p><p>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception <i>or</i> terminate the current request with a 500 status code immediately.
</p><p>The request body data read using this function can be retrieved later via <a href="#ngx.req.get_body_data">ngx.req.get_body_data</a> or, alternatively, the temporary file name for the body data cached to disk using <a href="#ngx.req.get_body_file">ngx.req.get_body_file</a>. This depends on
</p>
<ol><li> whether the current request body is already larger than the <a href="/HttpCoreModule#client_body_buffer_size" title="HttpCoreModule">client_body_buffer_size</a>,
</li><li> and whether <a href="/HttpCoreModule#client_body_in_file_only" title="HttpCoreModule">client_body_in_file_only</a> has been switched on.
</li></ol>
<p>In cases where current request may have a request body and the request body data is not required, The <a href="#ngx.req.discard_body">ngx.req.discard_body</a> function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=71" title="Edit section: ngx.req.discard body">edit</a>]</span> <span class="mw-headline" id="ngx.req.discard_body"> ngx.req.discard_body </span></h2>
<p><b>syntax:</b> <i>ngx.req.discard_body()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately. Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.
</p><p>This function is an asynchronous call and returns immediately.
</p><p>If the request body has already been read, this function does nothing and returns immediately.
</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.
</p><p>See also <a href="#ngx.req.read_body">ngx.req.read_body</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=72" title="Edit section: ngx.req.get body data">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_body_data"> ngx.req.get_body_data </span></h2>
<p><b>syntax:</b> <i>data = ngx.req.get_body_data()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the <a href="#ngx.req.get_post_args">ngx.req.get_post_args</a> function instead if a Lua table is required.
</p><p>This function returns <code>nil</code> if
</p>
<ol><li> the request body has not been read,
</li><li> the request body has been read into disk temporary files,
</li><li> or the request body has zero size.
</li></ol>
<p>If the request body has not been read yet, call <a href="#ngx.req.read_body">ngx.req.read_body</a> first (or turned on <a href="#lua_need_request_body">lua_need_request_body</a> to force this module to read the request body. This is not recommended however).
</p><p>If the request body has been read into disk files, try calling the <a href="#ngx.req.get_body_file">ngx.req.get_body_file</a> function instead.
</p><p>To force in-memory request bodies, try setting <a href="/HttpCoreModule#client_body_buffer_size" title="HttpCoreModule">client_body_buffer_size</a> to the same size value in <a href="/HttpCoreModule#client_max_body_size" title="HttpCoreModule">client_max_body_size</a>.
</p><p>Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request_body</code> is more efficient because it can save one dynamic memory allocation and one data copy.
</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.
</p><p>See also <a href="#ngx.req.get_body_file">ngx.req.get_body_file</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=73" title="Edit section: ngx.req.get body file">edit</a>]</span> <span class="mw-headline" id="ngx.req.get_body_file"> ngx.req.get_body_file </span></h2>
<p><b>syntax:</b> <i>file_name = ngx.req.get_body_file()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.
</p><p>The returned file is read only and is usually cleaned up by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.
</p><p>If the request body has not been read yet, call <a href="#ngx.req.read_body">ngx.req.read_body</a> first (or turned on <a href="#lua_need_request_body">lua_need_request_body</a> to force this module to read the request body. This is not recommended however).
</p><p>If the request body has been read into memory, try calling the <a href="#ngx.req.get_body_data">ngx.req.get_body_data</a> function instead.
</p><p>To force in-file request bodies, try turning on <a href="/HttpCoreModule#client_body_in_file_only" title="HttpCoreModule">client_body_in_file_only</a>.
</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.
</p><p>See also <a href="#ngx.req.get_body_data">ngx.req.get_body_data</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=74" title="Edit section: ngx.req.set body data">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_body_data"> ngx.req.set_body_data </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_body_data(data)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Set the current request's request body using the in-memory data specified by the <code>data</code> argument.
</p><p>If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.
</p><p>See also <a href="#ngx.req.set_body_file">ngx.req.set_body_file</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=75" title="Edit section: ngx.req.set body file">edit</a>]</span> <span class="mw-headline" id="ngx.req.set_body_file"> ngx.req.set_body_file </span></h2>
<p><b>syntax:</b> <i>ngx.req.set_body_file(file_name, auto_clean?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Set the current request's request body using the in-file data specified by the <code>file_name</code> argument.
</p><p>If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be removed at request completion or the next time this function or <a href="#ngx.req.set_body_data">ngx.req.set_body_data</a> are called in the same request. The <code>auto_clean</code> is default to <code>false</code>.
</p><p>Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.
</p><p>If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.
</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.
</p><p>See also <a href="#ngx.req.set_body_data">ngx.req.set_body_data</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=76" title="Edit section: ngx.req.init body">edit</a>]</span> <span class="mw-headline" id="ngx.req.init_body"> ngx.req.init_body </span></h2>
<p><b>syntax:</b> <i>ngx.req.init_body(buffer_size?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the <a href="#ngx.req.append_body">ngx.req.append_body</a> and <a href="#ngx.req.finish_body">ngx.req.finish_body</a> APIs.
</p><p>If the <code>buffer_size</code> argument is specified, then its value will be used for the size of the memory buffer for body writing with <a href="#ngx.req.append_body">ngx.req.append_body</a>. If the argument is omitted, then the value specified by the standard <a href="/HttpCoreModule#client_body_buffer_size" title="HttpCoreModule">client_body_buffer_size</a> directive will be used instead.
</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
</p><p>It is important to always call the <a href="#ngx.req.finish_body">ngx.req.finish_body</a> after all the data has been appended onto the current request body. Also, when this function is used together with <a href="#ngx.req.socket">ngx.req.socket</a>, it is required to call <a href="#ngx.req.socket">ngx.req.socket</a> <i>before</i> this function, or you will get the "request body already exists" error message.
</p><p>The usage of this function is often like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.req.init_body<span class="br0">(</span><span class="nu0">128</span> <span class="sy0">*</span> <span class="nu0">1024</span><span class="br0">)</span>  <span class="co1">-- buffer is 128KB</span>
    <span class="kw1">for</span> chunk <span class="kw1">in</span> next_data_chunk<span class="br0">(</span><span class="br0">)</span> <span class="kw1">do</span>
        ngx.req.append_body<span class="br0">(</span>chunk<span class="br0">)</span> <span class="co1">-- each chunk can be 4KB</span>
    <span class="kw1">end</span>
    ngx.req.finish_body<span class="br0">(</span><span class="br0">)</span></pre></div></div>
<p>This function can be used with <a href="#ngx.req.append_body">ngx.req.append_body</a>, <a href="#ngx.req.finish_body">ngx.req.finish_body</a>, and <a href="#ngx.req.socket">ngx.req.socket</a> to implement efficient input filters in pure Lua (in the context of <a href="#rewrite_by_lua">rewrite_by_lua</a>* or <a href="#access_by_lua">access_by_lua</a>*), which can be used with other Nginx content handler or upstream modules like <a href="/HttpProxyModule" title="HttpProxyModule">HttpProxyModule</a> and <a href="/HttpFastcgiModule" title="HttpFastcgiModule">HttpFastcgiModule</a>.
</p><p>This function was first introduced in the <code>v0.5.11</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=77" title="Edit section: ngx.req.append body">edit</a>]</span> <span class="mw-headline" id="ngx.req.append_body"> ngx.req.append_body </span></h2>
<p><b>syntax:</b> <i>ngx.req.append_body(data_chunk)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Append new data chunk specified by the <code>data_chunk</code> argument onto the existing request body created by the <a href="#ngx.req.init_body">ngx.req.init_body</a> call.
</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.
</p><p>It is important to always call the <a href="#ngx.req.finish_body">ngx.req.finish_body</a> after all the data has been appended onto the current request body.
</p><p>This function can be used with <a href="#ngx.req.init_body">ngx.req.init_body</a>, <a href="#ngx.req.finish_body">ngx.req.finish_body</a>, and <a href="#ngx.req.socket">ngx.req.socket</a> to implement efficient input filters in pure Lua (in the context of <a href="#rewrite_by_lua">rewrite_by_lua</a>* or <a href="#access_by_lua">access_by_lua</a>*), which can be used with other Nginx content handler or upstream modules like <a href="/HttpProxyModule" title="HttpProxyModule">HttpProxyModule</a> and <a href="/HttpFastcgiModule" title="HttpFastcgiModule">HttpFastcgiModule</a>.
</p><p>This function was first introduced in the <code>v0.5.11</code> release.
</p><p>See also <a href="#ngx.req.init_body">ngx.req.init_body</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=78" title="Edit section: ngx.req.finish body">edit</a>]</span> <span class="mw-headline" id="ngx.req.finish_body"> ngx.req.finish_body </span></h2>
<p><b>syntax:</b> <i>ngx.req.finish_body()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Completes the construction process of the new request body created by the <a href="#ngx.req.init_body">ngx.req.init_body</a> and <a href="#ngx.req.append_body">ngx.req.append_body</a> calls.
</p><p>This function can be used with <a href="#ngx.req.init_body">ngx.req.init_body</a>, <a href="#ngx.req.append_body">ngx.req.append_body</a>, and <a href="#ngx.req.socket">ngx.req.socket</a> to implement efficient input filters in pure Lua (in the context of <a href="#rewrite_by_lua">rewrite_by_lua</a>* or <a href="#access_by_lua">access_by_lua</a>*), which can be used with other Nginx content handler or upstream modules like <a href="/HttpProxyModule" title="HttpProxyModule">HttpProxyModule</a> and <a href="/HttpFastcgiModule" title="HttpFastcgiModule">HttpFastcgiModule</a>.
</p><p>This function was first introduced in the <code>v0.5.11</code> release.
</p><p>See also <a href="#ngx.req.init_body">ngx.req.init_body</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=79" title="Edit section: ngx.req.socket">edit</a>]</span> <span class="mw-headline" id="ngx.req.socket"> ngx.req.socket </span></h2>
<p><b>syntax:</b> <i>tcpsock, err = ngx.req.socket()</i>
</p><p><b>syntax:</b> <i>tcpsock, err = ngx.req.socket(raw)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Returns a read-only cosocket object that wraps the downstream connection. Only <a href="#tcpsock:receive">receive</a> and <a href="#tcpsock:receiveuntil">receiveuntil</a> methods are supported on this object.
</p><p>In case of error, <code>nil</code> will be returned as well as a string describing the error.
</p><p>The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the <a href="#lua_need_request_body">lua_need_request_body</a> directive, and do not mix this call with <a href="#ngx.req.read_body">ngx.req.read_body</a> and <a href="#ngx.req.discard_body">ngx.req.discard_body</a>.
</p><p>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.
Chunked request bodies are not yet supported in this API.
</p><p>Since the <code>v0.9.0</code> release, this function accepts an optional boolean <code>raw</code> argument. When this argument is <code>true</code>, this function returns a full duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the <a href="#tcpsock:receive">receive</a>, <a href="#tcpsock:receiveuntil">receiveuntil</a>, and <a href="#tcpsock:send">send</a> methods.
</p><p>When the <code>raw</code> argument is <code>true</code>, it is required that no pending data from any previous <a href="#ngx.say">ngx.say</a>, <a href="#ngx.print">ngx.print</a>, or <a href="#ngx.send_headers">ngx.send_headers</a> calls exists. So if you have these downstream output calls previously, you should call <a href="#ngx.flush">ngx.flush(true)</a> before calling <code>ngx.req.socket(true)</code> to ensure that there is no pending output data. Another requirement for this case is that the request body must have already been read completely.
</p><p>You can use the "raw request socket" returned by <code>ngx.req.socket(true)</code> to implement fancy protocols like <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/WebSocket">WebSocket</a>, or just emit your own raw HTTP response header or body data. You can refer to the <a rel="nofollow" class="external text" href="https://github.com/agentzh/lua-resty-websocket">lua-resty-websocket library</a> for a real world example.
</p><p>This function was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=80" title="Edit section: ngx.exec">edit</a>]</span> <span class="mw-headline" id="ngx.exec"> ngx.exec </span></h2>
<p><b>syntax:</b> <i>ngx.exec(uri, args?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Does an internal redirect to <code>uri</code> with <code>args</code>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.exec<span class="br0">(</span><span class="st0">'/some-location'</span><span class="br0">)</span><span class="sy0">;</span>
    ngx.exec<span class="br0">(</span><span class="st0">'/some-location'</span>, <span class="st0">'a=3&amp;b=5&amp;c=6'</span><span class="br0">)</span><span class="sy0">;</span>
    ngx.exec<span class="br0">(</span><span class="st0">'/some-location?a=3&amp;b=5'</span>, <span class="st0">'c=6'</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Named locations are also supported, but query strings are ignored. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        content_by_lua <span class="st0">'
            ngx.exec("@bar");
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="re0">@bar</span> <span class="br0">{</span>
        ...
    <span class="br0">}</span></pre></div></div>
<p>The optional second <code>args</code> can be used to specify extra URI query arguments, for example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.exec<span class="br0">(</span><span class="st0">"/foo"</span>, <span class="st0">"a=3&amp;b=hello%20world"</span><span class="br0">)</span></pre></div></div>
<p>Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.exec<span class="br0">(</span><span class="st0">"/foo"</span>, <span class="br0">{</span> a <span class="sy0">=</span> <span class="nu0">3</span>, b <span class="sy0">=</span> <span class="st0">"hello world"</span> <span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>The result is exactly the same as the previous example. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the <a href="#ngx.encode_args">ngx.encode_args</a> method.
</p><p>Note that this is very different from <a href="#ngx.redirect">ngx.redirect</a> in that
it is just an internal redirect and no new HTTP traffic is involved.
</p><p>This method never returns.
</p><p>This method <i>must</i> be called before <a href="#ngx.send_headers">ngx.send_headers</a> or explicit response body
outputs by either <a href="#ngx.print">ngx.print</a> or <a href="#ngx.say">ngx.say</a>.
</p><p>It is strongly recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exec(...)</code>.
</p><p>This method is similar to the <a href="/HttpEchoModule#echo_exec" title="HttpEchoModule">echo_exec</a> directive of the <a href="/HttpEchoModule" title="HttpEchoModule">HttpEchoModule</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=81" title="Edit section: ngx.redirect">edit</a>]</span> <span class="mw-headline" id="ngx.redirect"> ngx.redirect </span></h2>
<p><b>syntax:</b> <i>ngx.redirect(uri, status?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.
</p><p>The optional <code>status</code> parameter specifies whether
<code>301</code> or <code>302</code> to be used. It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.
</p><p>Here is an example assuming the current server name is <code>localhost</code> and that it is listening on Port 1984:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">"/foo"</span><span class="br0">)</span></pre></div></div>
<p>which is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">"http://localhost:1984/foo"</span>, ngx.HTTP_MOVED_TEMPORARILY<span class="br0">)</span></pre></div></div>
<p>Redirecting arbitrary external URLs is also supported, for example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">"http://www.google.com"</span><span class="br0">)</span></pre></div></div>
<p>We can also use the numerical code directly as the second <code>status</code> argument:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">"/foo"</span>, <span class="nu0">301</span><span class="br0">)</span></pre></div></div>
<p>This method <i>must</i> be called before <a href="#ngx.send_headers">ngx.send_headers</a> or explicit response body outputs by either <a href="#ngx.print">ngx.print</a> or <a href="#ngx.say">ngx.say</a>.
</p><p>This method is very much like the <a href="/HttpRewriteModule#rewrite" title="HttpRewriteModule">rewrite</a> directive with the <code>redirect</code> modifier in the standard
<a href="/HttpRewriteModule" title="HttpRewriteModule">HttpRewriteModule</a>, for example, this <code>nginx.conf</code> snippet
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /foo? redirect<span class="sy0">;</span>  <span class="co1"># nginx config</span></pre></div></div>
<p>is equivalent to the following Lua code
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">'/foo'</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">-- Lua code</span></pre></div></div>
<p>while
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpRewriteModule#rewrite"><span class="kw22">rewrite</span></a> ^ /foo? permanent<span class="sy0">;</span>  <span class="co1"># nginx config</span></pre></div></div>
<p>is equivalent to
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">'/foo'</span>, ngx.HTTP_MOVED_PERMANENTLY<span class="br0">)</span>  <span class="co1">-- Lua code</span></pre></div></div>
<p>URI arguments can be specified as well, for example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">return</span> ngx.redirect<span class="br0">(</span><span class="st0">'/foo?a=3&amp;b=4'</span><span class="br0">)</span></pre></div></div>
<p>This method call terminates the current request's processing and never returns. It is recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.redirect(...)</code>, so as to be more explicit.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=82" title="Edit section: ngx.send headers">edit</a>]</span> <span class="mw-headline" id="ngx.send_headers"> ngx.send_headers </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.send_headers()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Explicitly send out the response headers.
</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
</p><p>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out
before content is output with <a href="#ngx.say">ngx.say</a> or <a href="#ngx.print">ngx.print</a> or when <a href="#content_by_lua">content_by_lua</a> exits normally.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=83" title="Edit section: ngx.headers sent">edit</a>]</span> <span class="mw-headline" id="ngx.headers_sent"> ngx.headers_sent </span></h2>
<p><b>syntax:</b> <i>value = ngx.headers_sent</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.
</p><p>This API was first introduced in ngx_lua v0.3.1rc6.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=84" title="Edit section: ngx.print">edit</a>]</span> <span class="mw-headline" id="ngx.print"> ngx.print </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.print(...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.
</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
</p><p>Lua <code>nil</code> values will output <code>"nil"</code> strings and Lua boolean values will output <code>"true"</code> and <code>"false"</code> literal strings respectively.
</p><p>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> <span class="kw1">table</span> <span class="sy0">=</span> <span class="br0">{</span>
        <span class="st0">"hello, "</span>,
        <span class="br0">{</span><span class="st0">"world: "</span>, <span class="kw1">true</span>, <span class="st0">" or "</span>, <span class="kw1">false</span>,
            <span class="br0">{</span><span class="st0">": "</span>, <span class="kw1">nil</span><span class="br0">}</span><span class="br0">}</span>
    <span class="br0">}</span>
    ngx.<span class="kw1">print</span><span class="br0">(</span><span class="kw1">table</span><span class="br0">)</span></pre></div></div>
<p>will yield the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    hello, world: <span class="kw2">true</span> or <span class="kw2">false</span>: nil</pre></div></div>
<p>Non-array table arguments will cause a Lua exception to be thrown.
</p><p>The <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
</p><p>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See <a href="#ngx.flush">ngx.flush</a> for more details.
</p><p>Please note that both <code>ngx.print</code> and <a href="#ngx.say">ngx.say</a> will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=85" title="Edit section: ngx.say">edit</a>]</span> <span class="mw-headline" id="ngx.say"> ngx.say </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.say(...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Just as <a href="#ngx.print">ngx.print</a> but also emit a trailing newline.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=86" title="Edit section: ngx.log">edit</a>]</span> <span class="mw-headline" id="ngx.log"> ngx.log </span></h2>
<p><b>syntax:</b> <i>ngx.log(log_level, ...)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Log arguments concatenated to error.log with the given logging level.
</p><p>Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> string while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> string outputs. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.
</p><p>The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out <a href="#Nginx_log_level_constants">Nginx log level constants</a> for details.
</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=87" title="Edit section: ngx.flush">edit</a>]</span> <span class="mw-headline" id="ngx.flush"> ngx.flush </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.flush(wait?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Flushes response output to the client. 
</p><p><code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode. 
</p><p>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the <a href="/HttpCoreModule#send_timeout" title="HttpCoreModule">send_timeout</a> setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.
</p><p>When <code>ngx.flush(true)</code> is called immediately after <a href="#ngx.print">ngx.print</a> or <a href="#ngx.say">ngx.say</a>, it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.
</p><p>Note that <code>ngx.flush</code> is non functional when in the HTTP 1.0 output buffering mode. See <a href="#HTTP_1.0_support">HTTP 1.0 support</a>.
</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=88" title="Edit section: ngx.exit">edit</a>]</span> <span class="mw-headline" id="ngx.exit"> ngx.exit </span></h2>
<p><b>syntax:</b> <i>ngx.exit(status)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>When <code>status &gt;= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.
</p><p>When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the <a href="#content_by_lua">content_by_lua</a> directive is used) and continue to run later phases (if any) for the current request.
</p><p>The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
<code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other <a href="#HTTP_status_constants">HTTP status constants</a>.
</p><p>To return an error page with custom contents, use code snippets like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.status <span class="sy0">=</span> ngx.HTTP_GONE
    ngx.say<span class="br0">(</span><span class="st0">"This is our own content"</span><span class="br0">)</span>
    <span class="co1">-- to cause quit the whole request rather than the current phase handler</span>
    ngx.<span class="kw1">exit</span><span class="br0">(</span>ngx.HTTP_OK<span class="br0">)</span></pre></div></div>
<p>The effect in action:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    $ curl <span class="re5">-i</span> http:<span class="sy0">//</span>localhost<span class="sy0">/</span><span class="kw3">test</span>
    HTTP<span class="sy0">/</span><span class="nu0">1.1</span> <span class="nu0">410</span> Gone
    Server: nginx<span class="sy0">/</span>1.0.6
    Date: Thu, <span class="nu0">15</span> Sep <span class="nu0">2011</span> 00:<span class="nu0">51</span>:<span class="nu0">48</span> GMT
    Content-Type: text<span class="sy0">/</span>plain
    Transfer-Encoding: chunked
    Connection: keep-alive
&nbsp;
    This is our own content</pre></div></div>
<p>Number literals can be used directly as the argument, for instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.<span class="kw1">exit</span><span class="br0">(</span><span class="nu0">501</span><span class="br0">)</span></pre></div></div>
<p>Note that while this method accepts all <a href="#HTTP_status_constants">HTTP status constants</a> as input, it only accepts <code>NGX_OK</code> and <code>NGX_ERROR</code> of the <a href="#core_constants">core constants</a>.
</p><p>It is recommended, though not necessary, to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exit(...)</code>, to give a visual hint to others reading the code.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=89" title="Edit section: ngx.eof">edit</a>]</span> <span class="mw-headline" id="ngx.eof"> ngx.eof </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.eof()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the "last chunk".
</p><p>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on descent HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /async <span class="br0">{</span>
        <a href="/NginxHttpCoreModule#keepalive_timeout"><span class="kw3">keepalive_timeout</span></a> <span class="nu0">0</span><span class="sy0">;</span>
        content_by_lua <span class="st0">'
            ngx.say("got the task!")
            ngx.eof()  -- descent HTTP client will close the connection at this point
            -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard <a href="/HttpProxyModule" title="HttpProxyModule">HttpProxyModule</a> will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the <a href="/HttpProxyModule#proxy_ignore_client_abort" title="HttpProxyModule">proxy_ignore_client_abort</a> directive in your location block configured by <a href="/HttpProxyModule" title="HttpProxyModule">HttpProxyModule</a>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpProxyModule#proxy_ignore_client_abort"><span class="kw21">proxy_ignore_client_abort</span></a> on<span class="sy0">;</span></pre></div></div>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=90" title="Edit section: ngx.sleep">edit</a>]</span> <span class="mw-headline" id="ngx.sleep"> ngx.sleep </span></h2>
<p><b>syntax:</b> <i>ngx.sleep(seconds)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).
</p><p>Behind the scene, this method makes use of the Nginx timers.
</p><p>Since the <code>0.7.20</code> release, The <code>0</code> time argument can also be specified.
</p><p>This method was introduced in the <code>0.5.0rc30</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=91" title="Edit section: ngx.escape uri">edit</a>]</span> <span class="mw-headline" id="ngx.escape_uri"> ngx.escape_uri </span></h2>
<p><b>syntax:</b> <i>newstr = ngx.escape_uri(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Escape <code>str</code> as a URI component.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=92" title="Edit section: ngx.unescape uri">edit</a>]</span> <span class="mw-headline" id="ngx.unescape_uri"> ngx.unescape_uri </span></h2>
<p><b>syntax:</b> <i>newstr = ngx.unescape_uri(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Unescape <code>str</code> as an escaped URI component.
</p><p>For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.say<span class="br0">(</span>ngx.unescape_uri<span class="br0">(</span><span class="st0">"b%20r56+7"</span><span class="br0">)</span><span class="br0">)</span></pre></div></div>
<p>gives the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    b r56 7</pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=93" title="Edit section: ngx.encode args">edit</a>]</span> <span class="mw-headline" id="ngx.encode_args"> ngx.encode_args </span></h2>
<p><b>syntax:</b> <i>str = ngx.encode_args(table)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Encode the Lua table to a query args string according to the URI encoded rules.
</p><p>For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.encode_args<span class="br0">(</span><span class="br0">{</span>foo <span class="sy0">=</span> <span class="nu0">3</span>, <span class="br0">[</span><span class="st0">"b r"</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"hello world"</span><span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>yields
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    foo=3&amp;b%20r=hello%20world</pre></div></div>
<p>The table keys must be Lua strings.
</p><p>Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.encode_args<span class="br0">(</span><span class="br0">{</span>baz <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">32</span>, <span class="st0">"hello"</span><span class="br0">}</span><span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>gives
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    baz=32&amp;baz=hello</pre></div></div>
<p>If the value table is empty and the effect is equivalent to the <code>nil</code> value.
</p><p>Boolean argument values are also supported, for instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    ngx.encode_args<span class="br0">(</span><span class="br0">{</span>a <span class="sy0">=</span> <span class="kw1">true</span>, b <span class="sy0">=</span> <span class="nu0">1</span><span class="br0">}</span><span class="br0">)</span></pre></div></div>
<p>yields
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    a&amp;b=1</pre></div></div>
<p>If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.
</p><p>This method was first introduced in the <code>v0.3.1rc27</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=94" title="Edit section: ngx.decode args">edit</a>]</span> <span class="mw-headline" id="ngx.decode_args"> ngx.decode_args </span></h2>
<p><b>syntax:</b> <i>table = ngx.decode_args(str, max_args?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Decodes a URI encoded query-string into a Lua table. This is the inverse function of <a href="#ngx.encode_args">ngx.encode_args</a>.
</p><p>The optional <code>max_args</code> argument can be used to specify the maximum number of arguments parsed from the <code>str</code> argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.
</p><p>This argument can be set to zero to remove the limit and to process all request arguments received:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> args <span class="sy0">=</span> ngx.decode_args<span class="br0">(</span>str, <span class="nu0">0</span><span class="br0">)</span></pre></div></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.
</p><p>This method was introduced in the <code>v0.5.0rc29</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=95" title="Edit section: ngx.encode base64">edit</a>]</span> <span class="mw-headline" id="ngx.encode_base64"> ngx.encode_base64 </span></h2>
<p><b>syntax:</b> <i>newstr = ngx.encode_base64(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Encode <code>str</code> to a base64 digest.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=96" title="Edit section: ngx.decode base64">edit</a>]</span> <span class="mw-headline" id="ngx.decode_base64"> ngx.decode_base64 </span></h2>
<p><b>syntax:</b> <i>newstr = ngx.decode_base64(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=97" title="Edit section: ngx.crc32 short">edit</a>]</span> <span class="mw-headline" id="ngx.crc32_short"> ngx.crc32_short </span></h2>
<p><b>syntax:</b> <i>intval = ngx.crc32_short(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.
</p><p>This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to <a href="#ngx.crc32_long">ngx.crc32_long</a>. The result is exactly the same as <a href="#ngx.crc32_long">ngx.crc32_long</a>.
</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.
</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=98" title="Edit section: ngx.crc32 long">edit</a>]</span> <span class="mw-headline" id="ngx.crc32_long"> ngx.crc32_long </span></h2>
<p><b>syntax:</b> <i>intval = ngx.crc32_long(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.
</p><p>This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to <a href="#ngx.crc32_short">ngx.crc32_short</a>.  The result is exactly the same as <a href="#ngx.crc32_short">ngx.crc32_short</a>.
</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.
</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=99" title="Edit section: ngx.hmac sha1">edit</a>]</span> <span class="mw-headline" id="ngx.hmac_sha1"> ngx.hmac_sha1 </span></h2>
<p><b>syntax:</b> <i>digest = ngx.hmac_sha1(secret_key, str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Computes the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/HMAC">HMAC-SHA1</a> digest of the argument <code>str</code> and turns the result using the secret key <code>&lt;secret_key&gt;</code>.
</p><p>The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use <a href="#ngx.encode_base64">ngx.encode_base64</a>, for example, to encode the result to a textual representation if desired.
</p><p>For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> key <span class="sy0">=</span> <span class="st0">"thisisverysecretstuff"</span>
    <span class="kw1">local</span> src <span class="sy0">=</span> <span class="st0">"some string we want to sign"</span>
    <span class="kw1">local</span> digest <span class="sy0">=</span> ngx.hmac_sha1<span class="br0">(</span>key, src<span class="br0">)</span>
    ngx.say<span class="br0">(</span>ngx.encode_base64<span class="br0">(</span>digest<span class="br0">)</span><span class="br0">)</span></pre></div></div>
<p>yields the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    R/pvxzHC4NLtj7S+kXFg/NePTmk=</pre></div></div>
<p>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).
</p><p>This function was first introduced in the <code>v0.3.1rc29</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=100" title="Edit section: ngx.md5">edit</a>]</span> <span class="mw-headline" id="ngx.md5"> ngx.md5 </span></h2>
<p><b>syntax:</b> <i>digest = ngx.md5(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.
</p><p>For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> <span class="sy0">=</span> /md5 <span class="br0">{</span>
        content_by_lua <span class="st0">'ngx.say(ngx.md5("hello"))'</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>yields the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    5d41402abc4b2a76b9719d911017c592</pre></div></div>
<p>See <a href="#ngx.md5_bin">ngx.md5_bin</a> if the raw binary MD5 digest is required.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=101" title="Edit section: ngx.md5 bin">edit</a>]</span> <span class="mw-headline" id="ngx.md5_bin"> ngx.md5_bin </span></h2>
<p><b>syntax:</b> <i>digest = ngx.md5_bin(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the binary form of the MD5 digest of the <code>str</code> argument.
</p><p>See <a href="#ngx.md5">ngx.md5</a> if the hexadecimal form of the MD5 digest is required.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=102" title="Edit section: ngx.sha1 bin">edit</a>]</span> <span class="mw-headline" id="ngx.sha1_bin"> ngx.sha1_bin </span></h2>
<p><b>syntax:</b> <i>digest = ngx.sha1_bin(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the binary form of the SHA-1 digest of the <code>str</code> argument.
</p><p>This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).
</p><p>This function was first introduced in the <code>v0.5.0rc6</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=103" title="Edit section: ngx.quote sql str">edit</a>]</span> <span class="mw-headline" id="ngx.quote_sql_str"> ngx.quote_sql_str </span></h2>
<p><b>syntax:</b> <i>quoted_value = ngx.quote_sql_str(raw_value)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns a quoted SQL string literal according to the MySQL quoting rules.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=104" title="Edit section: ngx.today">edit</a>]</span> <span class="mw-headline" id="ngx.today"> ngx.today </span></h2>
<p><b>syntax:</b> <i>str = ngx.today()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua's date library).
</p><p>This is the local time.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=105" title="Edit section: ngx.time">edit</a>]</span> <span class="mw-headline" id="ngx.time"> ngx.time </span></h2>
<p><b>syntax:</b> <i>secs = ngx.time()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
</p><p>Updates of the Nginx time cache an be forced by calling <a href="#ngx.update_time">ngx.update_time</a> first.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=106" title="Edit section: ngx.now">edit</a>]</span> <span class="mw-headline" id="ngx.now"> ngx.now </span></h2>
<p><b>syntax:</b> <i>secs = ngx.now()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).
</p><p>You can forcibly update the Nginx time cache by calling <a href="#ngx.update_time">ngx.update_time</a> first.
</p><p>This API was first introduced in <code>v0.3.1rc32</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=107" title="Edit section: ngx.update time">edit</a>]</span> <span class="mw-headline" id="ngx.update_time"> ngx.update_time </span></h2>
<p><b>syntax:</b> <i>ngx.update_time()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.
</p><p>This API was first introduced in <code>v0.3.1rc32</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=108" title="Edit section: ngx.localtime">edit</a>]</span> <span class="mw-headline" id="ngx.localtime"> ngx.localtime </span></h2>
<p><b>syntax:</b> <i>str = ngx.localtime()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date">os.date</a> function).
</p><p>This is the local time.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=109" title="Edit section: ngx.utctime">edit</a>]</span> <span class="mw-headline" id="ngx.utctime"> ngx.utctime </span></h2>
<p><b>syntax:</b> <i>str = ngx.utctime()</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date">os.date</a> function).
</p><p>This is the UTC time.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=110" title="Edit section: ngx.cookie time">edit</a>]</span> <span class="mw-headline" id="ngx.cookie_time"> ngx.cookie_time </span></h2>
<p><b>syntax:</b> <i>str = ngx.cookie_time(sec)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns a formated string can be used as the cookie expiration time. The parameter <code>sec</code> is the time stamp in seconds (like those returned from <a href="#ngx.time">ngx.time</a>).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    ngx.say<span class="br0">(</span>ngx.cookie_time<span class="br0">(</span><span class="nu0">1290079655</span><span class="br0">)</span><span class="br0">)</span>
        -- yields <span class="st0">"Thu, 18-Nov-10 11:27:35 GMT"</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=111" title="Edit section: ngx.http time">edit</a>]</span> <span class="mw-headline" id="ngx.http_time"> ngx.http_time </span></h2>
<p><b>syntax:</b> <i>str = ngx.http_time(sec)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the time stamp in seconds (like those returned from <a href="#ngx.time">ngx.time</a>).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    ngx.say<span class="br0">(</span>ngx.http_time<span class="br0">(</span><span class="nu0">1290079655</span><span class="br0">)</span><span class="br0">)</span>
        -- yields <span class="st0">"Thu, 18 Nov 2010 11:27:35 GMT"</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=112" title="Edit section: ngx.parse http time">edit</a>]</span> <span class="mw-headline" id="ngx.parse_http_time"> ngx.parse_http_time </span></h2>
<p><b>syntax:</b> <i>sec = ngx.parse_http_time(str)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Parse the http time string (as returned by <a href="#ngx.http_time">ngx.http_time</a>) into seconds. Returns the seconds or <code>nil</code> if the input string is in bad forms.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    local time <span class="sy0">=</span> ngx.parse_http_time<span class="br0">(</span><span class="st0">"Thu, 18 Nov 2010 11:27:35 GMT"</span><span class="br0">)</span>
    <a href="/NginxHttpRewriteModule#if"><span class="kw22">if</span></a> time <span class="sy0">==</span> nil then
        ...
    end</pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=113" title="Edit section: ngx.is subrequest">edit</a>]</span> <span class="mw-headline" id="ngx.is_subrequest"> ngx.is_subrequest </span></h2>
<p><b>syntax:</b> <i>value = ngx.is_subrequest</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</i>
</p><p>Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=114" title="Edit section: ngx.re.match">edit</a>]</span> <span class="mw-headline" id="ngx.re.match"> ngx.re.match </span></h2>
<p><b>syntax:</b> <i>captures, err = ngx.re.match(subject, regex, options?, ctx?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Matches the <code>subject</code> string using the Perl compatible regular expression <code>regex</code> with the optional <code>options</code>.
</p><p>Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, <code>nil</code> and a string describing the error will be returned.
</p><p>When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized sub-pattern's capturing, <code>captures[2]</code> the second, and so on.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"[0-9]+"</span><span class="br0">)</span>
    <span class="kw1">if</span> m <span class="kw1">then</span>
        <span class="co1">-- m[0] == "1234"</span>
&nbsp;
    <span class="kw1">else</span>
        <span class="kw1">if</span> err <span class="kw1">then</span>
            ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
            <span class="kw1">return</span>
        <span class="kw1">end</span>
&nbsp;
        ngx.say<span class="br0">(</span><span class="st0">"match not found"</span><span class="br0">)</span>
    <span class="kw1">end</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"([0-9])[0-9]+"</span><span class="br0">)</span>
    <span class="co1">-- m[0] == "1234"</span>
    <span class="co1">-- m[1] == "1"</span></pre></div></div>
<p>Named captures are also supported since the <code>v0.7.14</code> release
and are returned in the same Lua table as key-value pairs as the numbered captures.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"([0-9])(?&lt;remaining&gt;[0-9]+)"</span><span class="br0">)</span>
    <span class="co1">-- m[0] == "1234"</span>
    <span class="co1">-- m[1] == "1"</span>
    <span class="co1">-- m[2] == "234"</span>
    <span class="co1">-- m["remaining"] == "234"</span></pre></div></div>
<p>Unmatched subpatterns will have <code>nil</code> values in their <code>captures</code> table fields.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, world"</span>, <span class="st0">"(world)|(hello)|(?&lt;named&gt;howdy)"</span><span class="br0">)</span>
    <span class="co1">-- m[0] == "hello"</span>
    <span class="co1">-- m[1] == nil</span>
    <span class="co1">-- m[2] == "hello"</span>
    <span class="co1">-- m[3] == nil</span>
    <span class="co1">-- m["named"] == nil</span></pre></div></div>
<p>Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    a             anchored mode (only match from the beginning)
&nbsp;
    d             enable the DFA mode (or the longest token match semantics).
                  this requires PCRE 6.0+ or else a Lua exception will be thrown.
                  first introduced in ngx_lua v0.3.1rc30.
&nbsp;
    D             enable duplicate named pattern support. This allows named
                  subpattern names to be repeated, returning the captures in
                  an array-like Lua table. for example,
                    local m = ngx.re.match("hello, world",
                                           "(?&lt;named&gt;\w+), (?&lt;named&gt;\w+)",
                                           "D")
                    -- m["named"] == {"hello", "world"}
                  this option was first introduced in the v0.7.14 release.
                  this option requires at least PCRE 8.12.
&nbsp;
    i             case insensitive mode (similar to Perl's /i modifier)
&nbsp;
    j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
                  must be built with the --enable-jit option. for optimum performance,
                  this option should always be used together with the 'o' option.
                  first introduced in ngx_lua v0.3.1rc30.
&nbsp;
    J             enable the PCRE Javascript compatible mode. this option was
                  first introduced in the v0.7.14 release. this option requires
                  at least PCRE 8.12.
&nbsp;
    m             multi-line mode (similar to Perl's /m modifier)
&nbsp;
    o             compile-once mode (similar to Perl's /o modifier),
                  to enable the worker-process-level compiled-regex cache
&nbsp;
    s             single-line mode (similar to Perl's /s modifier)
&nbsp;
    u             UTF-8 mode. this requires PCRE to be built with
                  the --enable-utf8 option or else a Lua exception will be thrown.
&nbsp;
    U             similar to "u" but disables PCRE's UTF-8 validity check on
                  the subject string. first introduced in ngx_lua v0.8.1.
&nbsp;
    x             extended mode (similar to Perl's /x modifier)</pre></div></div>
<p>These options can be combined:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    local m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, world"</span>, <span class="st0">"HEL LO"</span>, <span class="st0">"ix"</span><span class="br0">)</span>
    -- m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> <span class="st0">"hello"</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    local m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, "</span>, <span class="st0">"HELLO, (.{2})"</span>, <span class="st0">"iu"</span><span class="br0">)</span>
    -- m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> <span class="st0">"hello, "</span>
    -- m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> <span class="st0">""</span></pre></div></div>
<p>The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the <a href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a> directive.
</p><p>The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset. Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position <i>after</i> the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> ctx <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span>
    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"1234, hello"</span>, <span class="st0">"[0-9]+"</span>, <span class="st0">""</span>, ctx<span class="br0">)</span>
         <span class="co1">-- m[0] = "1234"</span>
         <span class="co1">-- ctx.pos == 4</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> ctx <span class="sy0">=</span> <span class="br0">{</span> pos <span class="sy0">=</span> <span class="nu0">2</span> <span class="br0">}</span>
    <span class="kw1">local</span> m, err <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"1234, hello"</span>, <span class="st0">"[0-9]+"</span>, <span class="st0">""</span>, ctx<span class="br0">)</span>
         <span class="co1">-- m[0] = "34"</span>
         <span class="co1">-- ctx.pos == 4</span></pre></div></div>
<p>The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.
</p><p>Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>""</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.
</p><p>This method requires the PCRE library enabled in Nginx.  (<a href="#Special_PCRE_Sequences">Known Issue With Special PCRE Sequences</a>).
</p><p>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the <code>--with-debug</code> option to Nginx or ngx_openresty's <code>./configure</code> script. Then, enable the "debug" error log level in <code>error_log</code> directive. The following message will be generated if PCRE JIT is enabled:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    pcre JIT compiling result: 1</pre></div></div>
<p>This feature was introduced in the <code>v0.2.1rc11</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=115" title="Edit section: ngx.re.gmatch">edit</a>]</span> <span class="mw-headline" id="ngx.re.gmatch"> ngx.re.gmatch </span></h2>
<p><b>syntax:</b> <i>iterator, err = ngx.re.gmatch(subject, regex, options?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Similar to <a href="#ngx.re.match">ngx.re.match</a>, but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the <code>&lt;subject&gt;</code> string argument with the PCRE <code>regex</code>.
</p><p>In case of errors, like seeing an ill-formed regular expression, <code>nil</code> and a string describing the error will be returned.
</p><p>Here is a small example to demonstrate its basic usage:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> iterator, err <span class="sy0">=</span> ngx.re.gmatch<span class="br0">(</span><span class="st0">"hello, world!"</span>, <span class="st0">"([a-z]+)"</span>, <span class="st0">"i"</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> iterator <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> m
    m, err <span class="sy0">=</span> iterator<span class="br0">(</span><span class="br0">)</span>    <span class="co1">-- m[0] == m[1] == "hello"</span>
    <span class="kw1">if</span> err <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    m, err <span class="sy0">=</span> iterator<span class="br0">(</span><span class="br0">)</span>    <span class="co1">-- m[0] == m[1] == "world"</span>
    <span class="kw1">if</span> err <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    m, err <span class="sy0">=</span> iterator<span class="br0">(</span><span class="br0">)</span>    <span class="co1">-- m == nil</span>
    <span class="kw1">if</span> err <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<p>More often we just put it into a Lua loop:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> it, err <span class="sy0">=</span> ngx.re.gmatch<span class="br0">(</span><span class="st0">"hello, world!"</span>, <span class="st0">"([a-z]+)"</span>, <span class="st0">"i"</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> it <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">while</span> <span class="kw1">true</span> <span class="kw1">do</span>
        <span class="kw1">local</span> m, err <span class="sy0">=</span> it<span class="br0">(</span><span class="br0">)</span>
        <span class="kw1">if</span> err <span class="kw1">then</span>
            ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
            <span class="kw1">return</span>
        <span class="kw1">end</span>
&nbsp;
        <span class="kw1">if</span> <span class="kw1">not</span> m <span class="kw1">then</span>
            <span class="co1">-- no match found (any more)</span>
            <span class="kw1">break</span>
        <span class="kw1">end</span>
&nbsp;
        <span class="co1">-- found a match</span>
        ngx.say<span class="br0">(</span>m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span>m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
    <span class="kw1">end</span></pre></div></div>
<p>The optional <code>options</code> argument takes exactly the same semantics as the <a href="#ngx.re.match">ngx.re.match</a> method.
</p><p>The current implementation requires that the iterator returned should only be used in a single request. That is, one should <i>not</i> assign it to a variable belonging to persistent namespace like a Lua package.
</p><p>This method requires the PCRE library enabled in Nginx.  (<a href="#Special_PCRE_Sequences">Known Issue With Special PCRE Sequences</a>).
</p><p>This feature was first introduced in the <code>v0.2.1rc12</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=116" title="Edit section: ngx.re.sub">edit</a>]</span> <span class="mw-headline" id="ngx.re.sub"> ngx.re.sub </span></h2>
<p><b>syntax:</b> <i>newstr, n, err = ngx.re.sub(subject, regex, replace, options?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in <a href="#ngx.re.match">ngx.re.match</a>.
</p><p>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code>&lt;replace&gt;</code> string argument, it will return <code>nil</code> and a string describing the error.
</p><p>When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.sub<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"([0-9])[0-9]"</span>, <span class="st0">"[$0][$1]"</span><span class="br0">)</span>
    <span class="kw1">if</span> newstr <span class="kw1">then</span>
        <span class="co1">-- newstr == "hello, [12][1]34"</span>
        <span class="co1">-- n == 1</span>
    <span class="kw1">else</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<p>where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.
</p><p>Curly braces can also be used to disambiguate variable names from the background string literals: 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.sub<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"[0-9]"</span>, <span class="st0">"${0}00"</span><span class="br0">)</span>
        <span class="co1">-- newstr == "hello, 10034"</span>
        <span class="co1">-- n == 1</span></pre></div></div>
<p>Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.sub<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"[0-9]"</span>, <span class="st0">"$$"</span><span class="br0">)</span>
        <span class="co1">-- newstr == "hello, $234"</span>
        <span class="co1">-- n == 1</span></pre></div></div>
<p>Do not use backlashes to escape dollar signs; it will not work as expected.
</p><p>When the <code>replace</code> argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the <code>replace</code> function is exactly the same as the return value of <a href="#ngx.re.match">ngx.re.match</a>. Here is an example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> func <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">(</span>m<span class="br0">)</span>
        <span class="kw1">return</span> <span class="st0">"["</span> .. m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> .. <span class="st0">"]["</span> .. m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> .. <span class="st0">"]"</span>
    <span class="kw1">end</span>
    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.sub<span class="br0">(</span><span class="st0">"hello, 1234"</span>, <span class="st0">"( [0-9] ) [0-9]"</span>, func, <span class="st0">"x"</span><span class="br0">)</span>
        <span class="co1">-- newstr == "hello, [12][1]34"</span>
        <span class="co1">-- n == 1</span></pre></div></div>
<p>The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.
</p><p>This method requires the PCRE library enabled in Nginx.  (<a href="#Special_PCRE_Sequences">Known Issue With Special PCRE Sequences</a>).
</p><p>This feature was first introduced in the <code>v0.2.1rc13</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=117" title="Edit section: ngx.re.gsub">edit</a>]</span> <span class="mw-headline" id="ngx.re.gsub"> ngx.re.gsub </span></h2>
<p><b>syntax:</b> <i>newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Just like <a href="#ngx.re.sub">ngx.re.sub</a>, but does global substitution.
</p><p>Here is some examples:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.<span class="kw1">gsub</span><span class="br0">(</span><span class="st0">"hello, world"</span>, <span class="st0">"([a-z])[a-z]+"</span>, <span class="st0">"[$0,$1]"</span>, <span class="st0">"i"</span><span class="br0">)</span>
    <span class="kw1">if</span> newstr <span class="kw1">then</span>
        <span class="co1">-- newstr == "[hello,h], [world,w]"</span>
        <span class="co1">-- n == 2</span>
    <span class="kw1">else</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"error: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> func <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">(</span>m<span class="br0">)</span>
        <span class="kw1">return</span> <span class="st0">"["</span> .. m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> .. <span class="st0">","</span> .. m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> .. <span class="st0">"]"</span>
    <span class="kw1">end</span>
    <span class="kw1">local</span> newstr, n, err <span class="sy0">=</span> ngx.re.<span class="kw1">gsub</span><span class="br0">(</span><span class="st0">"hello, world"</span>, <span class="st0">"([a-z])[a-z]+"</span>, func, <span class="st0">"i"</span><span class="br0">)</span>
        <span class="co1">-- newstr == "[hello,h], [world,w]"</span>
        <span class="co1">-- n == 2</span></pre></div></div>
<p>This method requires the PCRE library enabled in Nginx.  (<a href="#Special_PCRE_Sequences">Known Issue With Special PCRE Sequences</a>).
</p><p>This feature was first introduced in the <code>v0.2.1rc15</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=118" title="Edit section: ngx.shared.DICT">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT"> ngx.shared.DICT </span></h2>
<p><b>syntax:</b> <i>dict = ngx.shared.DICT</i>
</p><p><b>syntax:</b> <i>dict = ngx.shared[name_var]</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the <a href="#lua_shared_dict">lua_shared_dict</a> directive.
</p><p>The resulting object <code>dict</code> has the following methods:
</p>
<ul><li> <a href="#ngx.shared.DICT.get">get</a>
</li><li> <a href="#ngx.shared.DICT.get_stale">get_stale</a>
</li><li> <a href="#ngx.shared.DICT.set">set</a>
</li><li> <a href="#ngx.shared.DICT.safe_set">safe_set</a>
</li><li> <a href="#ngx.shared.DICT.add">add</a>
</li><li> <a href="#ngx.shared.DICT.safe_add">safe_add</a>
</li><li> <a href="#ngx.shared.DICT.replace">replace</a>
</li><li> <a href="#ngx.shared.DICT.incr">incr</a>
</li><li> <a href="#ngx.shared.DICT.delete">delete</a>
</li><li> <a href="#ngx.shared.DICT.flush_all">flush_all</a>
</li><li> <a href="#ngx.shared.DICT.flush_expired">flush_expired</a>
</li></ul>
<p>Here is an example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a> <span class="br0">{</span>
        lua_shared_dict dogs 10m<span class="sy0">;</span>
        <a href="/NginxHttpCoreModule#server"><span class="kw3">server</span></a> <span class="br0">{</span>
            <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /<a href="/NginxHttpRewriteModule#set"><span class="kw22">set</span></a> <span class="br0">{</span>
                content_by_lua <span class="st0">'
                    local dogs = ngx.shared.dogs
                    dogs:set("Jim", 8)
                    ngx.say("STORED")
                '</span><span class="sy0">;</span>
            <span class="br0">}</span>
            <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /get <span class="br0">{</span>
                content_by_lua <span class="st0">'
                    local dogs = ngx.shared.dogs
                    ngx.say(dogs:get("Jim"))
                '</span><span class="sy0">;</span>
            <span class="br0">}</span>
        <span class="br0">}</span>
    <span class="br0">}</span></pre></div></div>
<p>Let us test it:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    $ curl localhost<span class="sy0">/</span><span class="kw1">set</span>
    STORED
&nbsp;
    $ curl localhost<span class="sy0">/</span>get
    <span class="nu0">8</span>
&nbsp;
    $ curl localhost<span class="sy0">/</span>get
    <span class="nu0">8</span></pre></div></div>
<p>The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to <i>all</i> of the worker processes.
</p><p>The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).
</p><p>The contents in the dictionary storage will be lost, however, when the Nginx server quits.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=119" title="Edit section: ngx.shared.DICT.get">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.get"> ngx.shared.DICT.get </span></h2>
<p><b>syntax:</b> <i>value, flags = ngx.shared.DICT:get(key)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Retrieving the value in the dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a> for the key <code>key</code>. If the key does not exist or has been expired, then <code>nil</code> will be returned.
</p><p>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.
</p><p>The first argument to this method must be the dictionary object itself, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> cats <span class="sy0">=</span> ngx.shared.cats
    <span class="kw1">local</span> value, flags <span class="sy0">=</span> cats.get<span class="br0">(</span>cats, <span class="st0">"Marry"</span><span class="br0">)</span></pre></div></div>
<p>or use Lua's syntactic sugar for method calls:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> cats <span class="sy0">=</span> ngx.shared.cats
    <span class="kw1">local</span> value, flags <span class="sy0">=</span> cats:get<span class="br0">(</span><span class="st0">"Marry"</span><span class="br0">)</span></pre></div></div>
<p>These two forms are fundamentally equivalent.
</p><p>If the user flags is <code>0</code> (the default), then no flags value will be returned.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=120" title="Edit section: ngx.shared.DICT.get stale">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.get_stale"> ngx.shared.DICT.get_stale </span></h2>
<p><b>syntax:</b> <i>value, flags, stale = ngx.shared.DICT:get_stale(key)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Similar to the <a href="#ngx.shared.DICT.get">get</a> method but returns the value even if the key has already expired.
</p><p>Returns a 3rd value, <code>stale</code>, indicating whether the key has expired or not.
</p><p>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.
</p><p>This method was first introduced in the <code>0.8.6</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=121" title="Edit section: ngx.shared.DICT.set">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.set"> ngx.shared.DICT.set </span></h2>
<p><b>syntax:</b> <i>success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Unconditionally sets a key-value pair into the shm-based dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a>. Returns three values:
</p>
<ul><li> <code>success</code>: boolean value to indicate whether the key-value pair is stored or not.
</li><li> <code>err</code>: textual error message, can be <code>"no memory"</code>.
</li><li> <code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.
</li></ul>
<p>The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the <a href="#ngx.shared.DICT.get">get</a> method.
</p><p>The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never be expired.
</p><p>The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.
</p><p>When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by <a href="#lua_shared_dict">lua_shared_dict</a> or memory segmentation), then the <code>err</code> return value will be <code>no memory</code> and <code>success</code> will be <code>false</code>.
</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.
</p><p>The first argument to this method must be the dictionary object itself, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> cats <span class="sy0">=</span> ngx.shared.cats
    <span class="kw1">local</span> succ, err, forcible <span class="sy0">=</span> cats.set<span class="br0">(</span>cats, <span class="st0">"Marry"</span>, <span class="st0">"it is a nice cat!"</span><span class="br0">)</span></pre></div></div>
<p>or use Lua's syntactic sugar for method calls:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> cats <span class="sy0">=</span> ngx.shared.cats
    <span class="kw1">local</span> succ, err, forcible <span class="sy0">=</span> cats:set<span class="br0">(</span><span class="st0">"Marry"</span>, <span class="st0">"it is a nice cat!"</span><span class="br0">)</span></pre></div></div>
<p>These two forms are fundamentally equivalent.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=122" title="Edit section: ngx.shared.DICT.safe set">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.safe_set"> ngx.shared.DICT.safe_set </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Similar to the <a href="#ngx.shared.DICT.set">set</a> method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string "no memory".
</p><p>This feature was first introduced in the <code>v0.7.18</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=123" title="Edit section: ngx.shared.DICT.add">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.add"> ngx.shared.DICT.add </span></h2>
<p><b>syntax:</b> <i>success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Just like the <a href="#ngx.shared.DICT.set">set</a> method, but only stores the key-value pair into the dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a> if the key does <i>not</i> exist.
</p><p>If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"exists"</code>.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=124" title="Edit section: ngx.shared.DICT.safe add">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.safe_add"> ngx.shared.DICT.safe_add </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Similar to the <a href="#ngx.shared.DICT.add">add</a> method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string "no memory".
</p><p>This feature was first introduced in the <code>v0.7.18</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=125" title="Edit section: ngx.shared.DICT.replace">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.replace"> ngx.shared.DICT.replace </span></h2>
<p><b>syntax:</b> <i>success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Just like the <a href="#ngx.shared.DICT.set">set</a> method, but only stores the key-value pair into the dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a> if the key <i>does</i> exist.
</p><p>If the <code>key</code> argument does <i>not</i> exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"not found"</code>.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=126" title="Edit section: ngx.shared.DICT.delete">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.delete"> ngx.shared.DICT.delete </span></h2>
<p><b>syntax:</b> <i>ngx.shared.DICT:delete(key)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Unconditionally removes the key-value pair from the shm-based dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p><p>It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=127" title="Edit section: ngx.shared.DICT.incr">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.incr"> ngx.shared.DICT.incr </span></h2>
<p><b>syntax:</b> <i>newval, err = ngx.shared.DICT:incr(key, value)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Increments the (numerical) value for <code>key</code> in the shm-based dictionary <a href="#ngx.shared.DICT">ngx.shared.DICT</a> by the step value <code>value</code>. Returns the new resulting number if the operation is successfully completed or <code>nil</code> and an error message otherwise.
</p><p>The key must already exist in the dictionary, otherwise it will return <code>nil</code> and <code>"not found"</code>.
</p><p>If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>"not a number"</code>.
</p><p>The <code>value</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.
</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.
</p><p>See also <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=128" title="Edit section: ngx.shared.DICT.flush all">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.flush_all"> ngx.shared.DICT.flush_all </span></h2>
<p><b>syntax:</b> <i>ngx.shared.DICT:flush_all()</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.
</p><p>This feature was first introduced in the <code>v0.5.0rc17</code> release.
</p><p>See also <a href="#ngx.shared.DICT.flush_expired">ngx.shared.DICT.flush_expired</a> and <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=129" title="Edit section: ngx.shared.DICT.flush expired">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.flush_expired"> ngx.shared.DICT.flush_expired </span></h2>
<p><b>syntax:</b> <i>flushed = ngx.shared.DICT:flush_expired(max_count?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional <code>max_count</code> argument. When the <code>max_count</code> argument is given <code>0</code> or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.
</p><p>Unlike the <a href="#ngx.shared.DICT.flush_all">flush_all</a> method, this method actually free up the memory used by the expired items.
</p><p>This feature was first introduced in the <code>v0.6.3</code> release.
</p><p>See also <a href="#ngx.shared.DICT.flush_all">ngx.shared.DICT.flush_all</a> and <a href="#ngx.shared.DICT">ngx.shared.DICT</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=130" title="Edit section: ngx.shared.DICT.get keys">edit</a>]</span> <span class="mw-headline" id="ngx.shared.DICT.get_keys"> ngx.shared.DICT.get_keys </span></h2>
<p><b>syntax:</b> <i>keys = ngx.shared.DICT:get_keys(max_count?)</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Fetch a list of the keys from the dictionary, up to <code>&lt;max_count&gt;</code>.
</p><p>By default, only the first 1024 keys (if any) are returned. When the <code>&lt;max_count&gt;</code> argument is given the value <code>0</code>, then all the keys will be returned even there is more than 1024 keys in the dictionary.
</p><p><b>WARNING</b> Be careful when calling this method on dictionaries with a really huge number of keys. This method may lock the dictionary for quite a while and block all the nginx worker processes that are trying to access the dictionary.
</p><p>This feature was first introduced in the <code>v0.7.3</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=131" title="Edit section: ngx.socket.udp">edit</a>]</span> <span class="mw-headline" id="ngx.socket.udp"> ngx.socket.udp </span></h2>
<p><b>syntax:</b> <i>udpsock = ngx.socket.udp()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
</p>
<ul><li> <a href="#udpsock:setpeername">setpeername</a>
</li><li> <a href="#udpsock:send">send</a>
</li><li> <a href="#udpsock:receive">receive</a>
</li><li> <a href="#udpsock:close">close</a>
</li><li> <a href="#udpsock:settimeout">settimeout</a>
</li></ul>
<p>It is intended to be compatible with the UDP API of the <a rel="nofollow" class="external text" href="http://w3.impa.br/~diego/software/luasocket/udp.html">LuaSocket</a> library but is 100% nonblocking out of the box.
</p><p>This feature was first introduced in the <code>v0.5.7</code> release.
</p><p>See also <a href="#ngx.socket.tcp">ngx.socket.tcp</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=132" title="Edit section: udpsock:setpeername">edit</a>]</span> <span class="mw-headline" id="udpsock:setpeername"> udpsock:setpeername </span></h2>
<p><b>syntax:</b> <i>ok, err = udpsock:setpeername(host, port)</i>
</p><p><b>syntax:</b> <i>ok, err = udpsock:setpeername("unix:/path/to/unix-domain.socket")</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a "connection", but only just set the name of the remote peer for subsequent read/write operations.
</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="/HttpCoreModule#resolver" title="HttpCoreModule">resolver</a> directive in the <code>nginx.conf</code> file like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    resolver 8.8.8.8<span class="sy0">;</span>  <span class="co1"># use Google's public DNS nameserver</span></pre></div></div>
<p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.
</p><p>Here is an example for connecting to a UDP (memcached) server:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        resolver 8.8.8.8<span class="sy0">;</span>
&nbsp;
        content_by_lua <span class="st0">'
            local sock = ngx.socket.udp()
            local ok, err = sock:setpeername("my.memcached.server.domain", 11211)
            if not ok then
                ngx.say("failed to connect to memcached: ", err)
                return
            end
            ngx.say("successfully connected to memcached!")
            sock:close()
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Since the <code>v0.7.18</code> release, connecting to a datagram unix domain socket file is also possible on Linux:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> sock <span class="sy0">=</span> ngx.socket.udp<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> sock:setpeername<span class="br0">(</span><span class="st0">"unix:/tmp/some-datagram-service.sock"</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to connect to the datagram unix domain socket: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<p>assuming the datagram service is listening on the unix domain socket file <code>/tmp/some-datagram-service.sock</code> and the client socket will use the "autobind" feature on Linux.
</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.
</p><p>This method was first introduced in the <code>v0.5.7</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=133" title="Edit section: udpsock:send">edit</a>]</span> <span class="mw-headline" id="udpsock:send"> udpsock:send </span></h2>
<p><b>syntax:</b> <i>ok, err = udpsock:send(data)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Sends data on the current UDP or datagram unix domain socket object.
</p><p>In case of success, it returns <code>1</code>. Otherwise, it returns <code>nil</code> and a string describing the error.
</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
</p><p>This feature was first introduced in the <code>v0.5.7</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=134" title="Edit section: udpsock:receive">edit</a>]</span> <span class="mw-headline" id="udpsock:receive"> udpsock:receive </span></h2>
<p><b>syntax:</b> <i>data, err = udpsock:receive(size?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, <code>size</code>.
</p><p>This method is a synchronous operation and is 100% nonblocking.
</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.
</p><p>If the <code>size</code> argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than <code>8192</code>, then <code>8192</code> will be used instead.
</p><p>If no argument is specified, then the maximal buffer size, <code>8192</code> is assumed.
</p><p>Timeout for the reading operation is controlled by the <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config directive and the <a href="#udpsock:settimeout">settimeout</a> method. And the latter takes priority. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    sock:settimeout<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>  <span class="co1">-- one second timeout</span>
    <span class="kw1">local</span> data, err <span class="sy0">=</span> sock:receive<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> data <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to read a packet: "</span>, data<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
    ngx.say<span class="br0">(</span><span class="st0">"successfully read a packet: "</span>, data<span class="br0">)</span></pre></div></div>
<p>It is important here to call the <a href="#udpsock:settimeout">settimeout</a> method <i>before</i> calling this method.
</p><p>This feature was first introduced in the <code>v0.5.7</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=135" title="Edit section: udpsock:close">edit</a>]</span> <span class="mw-headline" id="udpsock:close"> udpsock:close </span></h2>
<p><b>syntax:</b> <i>ok, err = udpsock:close()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Closes the current UDP or datagram unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.
</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
</p><p>This feature was first introduced in the <code>v0.5.7</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=136" title="Edit section: udpsock:settimeout">edit</a>]</span> <span class="mw-headline" id="udpsock:settimeout"> udpsock:settimeout </span></h2>
<p><b>syntax:</b> <i>udpsock:settimeout(time)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Set the timeout value in milliseconds for subsequent socket operations (like <a href="#udpsock:receive">receive</a>).
</p><p>Settings done by this method takes priority over those config directives, like <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a>.
</p><p>This feature was first introduced in the <code>v0.5.7</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=137" title="Edit section: ngx.socket.tcp">edit</a>]</span> <span class="mw-headline" id="ngx.socket.tcp"> ngx.socket.tcp </span></h2>
<p><b>syntax:</b> <i>tcpsock = ngx.socket.tcp()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:
</p>
<ul><li> <a href="#tcpsock:connect">connect</a>
</li><li> <a href="#tcpsock:send">send</a>
</li><li> <a href="#tcpsock:receive">receive</a>
</li><li> <a href="#tcpsock:close">close</a>
</li><li> <a href="#tcpsock:settimeout">settimeout</a>
</li><li> <a href="#tcpsock:setoption">setoption</a>
</li><li> <a href="#tcpsock:receiveuntil">receiveuntil</a>
</li><li> <a href="#tcpsock:setkeepalive">setkeepalive</a>
</li><li> <a href="#tcpsock:getreusedtimes">getreusedtimes</a>
</li></ul>
<p>It is intended to be compatible with the TCP API of the <a rel="nofollow" class="external text" href="http://w3.impa.br/~diego/software/luasocket/tcp.html">LuaSocket</a> library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p><p>See also <a href="#ngx.socket.udp">ngx.socket.udp</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=138" title="Edit section: tcpsock:connect">edit</a>]</span> <span class="mw-headline" id="tcpsock:connect"> tcpsock:connect </span></h2>
<p><b>syntax:</b> <i>ok, err = tcpsock:connect(host, port, options_table?)</i>
</p><p><b>syntax:</b> <i>ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket", options_table?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.
</p><p>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the <a href="#ngx.socket.connect">ngx.socket.connect</a> function).
</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="/HttpCoreModule#resolver" title="HttpCoreModule">resolver</a> directive in the <code>nginx.conf</code> file like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    resolver 8.8.8.8<span class="sy0">;</span>  <span class="co1"># use Google's public DNS nameserver</span></pre></div></div>
<p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.
</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.
</p><p>Here is an example for connecting to a TCP server:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        resolver 8.8.8.8<span class="sy0">;</span>
&nbsp;
        content_by_lua <span class="st0">'
            local sock = ngx.socket.tcp()
            local ok, err = sock:connect("www.google.com", 80)
            if not ok then
                ngx.say("failed to connect to google: ", err)
                return
            end
            ngx.say("successfully connected to google!")
            sock:close()
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>Connecting to a Unix Domain Socket file is also possible:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> sock <span class="sy0">=</span> ngx.socket.tcp<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> sock:connect<span class="br0">(</span><span class="st0">"unix:/tmp/memcached.sock"</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to connect to the memcached unix domain socket: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<p>assuming memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.
</p><p>Timeout for the connecting operation is controlled by the <a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a> config directive and the <a href="#tcpsock:settimeout">settimeout</a> method. And the latter takes priority. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> sock <span class="sy0">=</span> ngx.socket.tcp<span class="br0">(</span><span class="br0">)</span>
    sock:settimeout<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>  <span class="co1">-- one second timeout</span>
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> sock:connect<span class="br0">(</span>host, port<span class="br0">)</span></pre></div></div>
<p>It is important here to call the <a href="#tcpsock:settimeout">settimeout</a> method <i>before</i> calling this method.
</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.
</p><p>An optional Lua table can be specified as the last argument to this method to specify various connect options:
</p>
<ul><li> <code>pool</code>
</li></ul>
<dl><dd> specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template <code>"&lt;host&gt;:&lt;port&gt;"</code> or <code>"&lt;unix-socket-path&gt;"</code>.
</dd></dl>
<p>The support for the options table argument was first introduced in the <code>v0.5.7</code> release.
</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=139" title="Edit section: tcpsock:send">edit</a>]</span> <span class="mw-headline" id="tcpsock:send"> tcpsock:send </span></h2>
<p><b>syntax:</b> <i>bytes, err = tcpsock:send(data)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Sends data without blocking on the current TCP or Unix Domain Socket connection.
</p><p>This method is a synchronous operation that will not return until <i>all</i> the data has been flushed into the system socket send buffer or an error occurs.
</p><p>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.
</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.
</p><p>Timeout for the sending operation is controlled by the <a href="#lua_socket_send_timeout">lua_socket_send_timeout</a> config directive and the <a href="#tcpsock:settimeout">settimeout</a> method. And the latter takes priority. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    sock:settimeout<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>  <span class="co1">-- one second timeout</span>
    <span class="kw1">local</span> bytes, err <span class="sy0">=</span> sock:send<span class="br0">(</span>request<span class="br0">)</span></pre></div></div>
<p>It is important here to call the <a href="#tcpsock:settimeout">settimeout</a> method <i>before</i> calling this method.
</p><p>In case of any connection errors, this method always automatically closes the current connection.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=140" title="Edit section: tcpsock:receive">edit</a>]</span> <span class="mw-headline" id="tcpsock:receive"> tcpsock:receive </span></h2>
<p><b>syntax:</b> <i>data, err, partial = tcpsock:receive(size)</i>
</p><p><b>syntax:</b> <i>data, err, partial = tcpsock:receive(pattern?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Receives data from the connected socket according to the reading pattern or size.
</p><p>This method is a synchronous operation just like the <a href="#tcpsock:send">send</a> method and is 100% nonblocking.
</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.
</p><p>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.
</p><p>If a non-number-like string argument is specified, then it is interpreted as a "pattern". The following patterns are supported:
</p>
<ul><li> <code>'*a'</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;
</li><li> <code>'*l'</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.
</li></ul>
<p>If no argument is specified, then it is assumed to be the pattern <code>'*l'</code>, that is, the line reading pattern.
</p><p>Timeout for the reading operation is controlled by the <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config directive and the <a href="#tcpsock:settimeout">settimeout</a> method. And the latter takes priority. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    sock:settimeout<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>  <span class="co1">-- one second timeout</span>
    <span class="kw1">local</span> line, err, partial <span class="sy0">=</span> sock:receive<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> line <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to read a line: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
    ngx.say<span class="br0">(</span><span class="st0">"successfully read a line: "</span>, line<span class="br0">)</span></pre></div></div>
<p>It is important here to call the <a href="#tcpsock:settimeout">settimeout</a> method <i>before</i> calling this method.
</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=141" title="Edit section: tcpsock:receiveuntil">edit</a>]</span> <span class="mw-headline" id="tcpsock:receiveuntil"> tcpsock:receiveuntil </span></h2>
<p><b>syntax:</b> <i>iterator = tcpsock:receiveuntil(pattern, options?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.
</p><p>Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> reader <span class="sy0">=</span> sock:receiveuntil<span class="br0">(</span><span class="st0">"<span class="es0">\r</span><span class="es0">\n</span>--abcedhb"</span><span class="br0">)</span>
    <span class="kw1">local</span> data, err, partial <span class="sy0">=</span> reader<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> data <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to read the data stream: "</span>, err<span class="br0">)</span>
    <span class="kw1">end</span>
    ngx.say<span class="br0">(</span><span class="st0">"read the data stream: "</span>, data<span class="br0">)</span></pre></div></div>
<p>When called without any argument, the iterator function returns the received data right <i>before</i> the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, then the string <code>'hello, world! -agentzh'</code> will be returned.
</p><p>In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.
</p><p>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.
</p><p>The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data on each invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will be reset after the last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> reader <span class="sy0">=</span> sock:receiveuntil<span class="br0">(</span><span class="st0">"<span class="es0">\r</span><span class="es0">\n</span>--abcedhb"</span><span class="br0">)</span>
&nbsp;
    <span class="kw1">while</span> <span class="kw1">true</span> <span class="kw1">do</span>
        <span class="kw1">local</span> data, err, partial <span class="sy0">=</span> reader<span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span>
        <span class="kw1">if</span> <span class="kw1">not</span> data <span class="kw1">then</span>
            <span class="kw1">if</span> err <span class="kw1">then</span>
                ngx.say<span class="br0">(</span><span class="st0">"failed to read the data stream: "</span>, err<span class="br0">)</span>
                <span class="kw1">break</span>
            <span class="kw1">end</span>
&nbsp;
            ngx.say<span class="br0">(</span><span class="st0">"read done"</span><span class="br0">)</span>
            <span class="kw1">break</span>
        <span class="kw1">end</span>
        ngx.say<span class="br0">(</span><span class="st0">"read chunk: ["</span>, data, <span class="st0">"]"</span><span class="br0">)</span>
    <span class="kw1">end</span></pre></div></div>
<p>Then for the incoming data stream <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, we shall get the following output from the sample code above:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    read chunk: [hell]
    read chunk: [o, w]
    read chunk: [orld]
    read chunk: [! -a]
    read chunk: [gent]
    read chunk: [zh]
    read done</pre></div></div>
<p>Note that, the actual data returned <i>might</i> be a little longer than the size limit specified by the <code>size</code> argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.
</p><p>Timeout for the iterator function's reading operation is controlled by the <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config directive and the <a href="#tcpsock:settimeout">settimeout</a> method. And the latter takes priority. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> readline <span class="sy0">=</span> sock:receiveuntil<span class="br0">(</span><span class="st0">"<span class="es0">\r</span><span class="es0">\n</span>"</span><span class="br0">)</span>
&nbsp;
    sock:settimeout<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>  <span class="co1">-- one second timeout</span>
    line, err, partial <span class="sy0">=</span> readline<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> line <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to read a line: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
    ngx.say<span class="br0">(</span><span class="st0">"successfully read a line: "</span>, line<span class="br0">)</span></pre></div></div>
<p>It is important here to call the <a href="#tcpsock:settimeout">settimeout</a> method <i>before</i> calling the iterator function (note that the <code>receiveuntil</code> call is irrelevant here).
</p><p>As from the <code>v0.5.1</code> release, this method also takes an optional <code>options</code> table argument to control the behavior. The following options are supported:
</p>
<ul><li> <code>inclusive</code>
</li></ul>
<p>The <code>inclusive</code> takes a boolean value to control whether to include the pattern string in the returned data string. Default to <code>false</code>. For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> reader <span class="sy0">=</span> tcpsock:receiveuntil<span class="br0">(</span><span class="st0">"_END_"</span>, <span class="br0">{</span> inclusive <span class="sy0">=</span> <span class="kw1">true</span> <span class="br0">}</span><span class="br0">)</span>
    <span class="kw1">local</span> data <span class="sy0">=</span> reader<span class="br0">(</span><span class="br0">)</span>
    ngx.say<span class="br0">(</span>data<span class="br0">)</span></pre></div></div>
<p>Then for the input data stream <code>"hello world _END_ blah blah blah"</code>, then the example above will output <code>hello world _END_</code>, including the pattern string <code>_END_</code> itself.
</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.
</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=142" title="Edit section: tcpsock:close">edit</a>]</span> <span class="mw-headline" id="tcpsock:close"> tcpsock:close </span></h2>
<p><b>syntax:</b> <i>ok, err = tcpsock:close()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Closes the current TCP or stream unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.
</p><p>Note that there is no need to call this method on socket objects that have invoked the <a href="#tcpsock:setkeepalive">setkeepalive</a> method because the socket object is already closed (and the current connection is saved into the built-in connection pool).
</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=143" title="Edit section: tcpsock:settimeout">edit</a>]</span> <span class="mw-headline" id="tcpsock:settimeout"> tcpsock:settimeout </span></h2>
<p><b>syntax:</b> <i>tcpsock:settimeout(time)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Set the timeout value in milliseconds for subsequent socket operations (<a href="#tcpsock:connect">connect</a>, <a href="#tcpsock:receive">receive</a>, and iterators returned from <a href="#tcpsock:receiveuntil">receiveuntil</a>).
</p><p>Settings done by this method takes priority over those config directives, i.e., <a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a>, <a href="#lua_socket_send_timeout">lua_socket_send_timeout</a>, and <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a>.
</p><p>Note that this method does <i>not</i> affect the <a href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a> setting; the <code>timeout</code> argument to the <a href="#tcpsock:setkeepalive">setkeepalive</a> method should be used for this purpose instead.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=144" title="Edit section: tcpsock:setoption">edit</a>]</span> <span class="mw-headline" id="tcpsock:setoption"> tcpsock:setoption </span></h2>
<p><b>syntax:</b> <i>tcpsock:setoption(option, value?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>This function is added for <a rel="nofollow" class="external text" href="http://w3.impa.br/~diego/software/luasocket/tcp.html">LuaSocket</a> API compatibility and does nothing for now. Its functionality will be implemented in future.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=145" title="Edit section: tcpsock:setkeepalive">edit</a>]</span> <span class="mw-headline" id="tcpsock:setkeepalive"> tcpsock:setkeepalive </span></h2>
<p><b>syntax:</b> <i>ok, err = tcpsock:setkeepalive(timeout?, size?)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other <a href="#tcpsock:connect">connect</a> method calls request it or the associated maximal idle timeout is expired.
</p><p>The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the <a href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a> config directive will be used. If the <code>0</code> value is given, then the timeout interval is unlimited.
</p><p>The second optional argument, <code>size</code>, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the <a href="#lua_socket_pool_size">lua_socket_pool_size</a> config directive will be used.
</p><p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.
</p><p>Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.
</p><p>Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.
</p><p>In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.
</p><p>This method also makes the current cosocket object enter the "closed" state, so there is no need to manually call the <a href="#tcpsock:close">close</a> method on it afterwards.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=146" title="Edit section: tcpsock:getreusedtimes">edit</a>]</span> <span class="mw-headline" id="tcpsock:getreusedtimes"> tcpsock:getreusedtimes </span></h2>
<p><b>syntax:</b> <i>count, err = tcpsock:getreusedtimes()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.
</p><p>If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=147" title="Edit section: ngx.socket.connect">edit</a>]</span> <span class="mw-headline" id="ngx.socket.connect"> ngx.socket.connect </span></h2>
<p><b>syntax:</b> <i>tcpsock, err = ngx.socket.connect(host, port)</i>
</p><p><b>syntax:</b> <i>tcpsock, err = ngx.socket.connect("unix:/path/to/unix-domain.socket")</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>This function is a shortcut for combining <a href="#ngx.socket.tcp">ngx.socket.tcp()</a> and the <a href="#tcpsock:connect">connect()</a> method call in a single operation. It is actually implemented like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> sock <span class="sy0">=</span> ngx.socket.tcp<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> sock:connect<span class="br0">(</span>...<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        <span class="kw1">return</span> <span class="kw1">nil</span>, err
    <span class="kw1">end</span>
    <span class="kw1">return</span> sock</pre></div></div>
<p>There is no way to use the <a href="#tcpsock:settimeout">settimeout</a> method to specify connecting timeout for this method and the <a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a> directive must be set at configure time instead.
</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=148" title="Edit section: ngx.get phase">edit</a>]</span> <span class="mw-headline" id="ngx.get_phase"> ngx.get_phase </span></h2>
<p><b>syntax:</b> <i>str = ngx.get_phase()</i>
</p><p><b>context:</b> <i>init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Retrieves the current running phase name. Possible return values are
</p>
<ul><li> <code>init</code>
</li></ul>
<dl><dd> for the context of <a href="#init_by_lua">init_by_lua</a> or <a href="#init_by_lua_file">init_by_lua_file</a>.
</dd></dl>
<ul><li> <code>set</code>
</li></ul>
<dl><dd> for the context of <a href="#set_by_lua">set_by_lua</a> or <a href="#set_by_lua_file">set_by_lua_file</a>.
</dd></dl>
<ul><li> <code>rewrite</code>
</li></ul>
<dl><dd> for the context of <a href="#rewrite_by_lua">rewrite_by_lua</a> or <a href="#rewrite_by_lua_file">rewrite_by_lua_file</a>.
</dd></dl>
<ul><li> <code>access</code>
</li></ul>
<dl><dd> for the context of <a href="#access_by_lua">access_by_lua</a> or <a href="#access_by_lua_file">access_by_lua_file</a>.
</dd></dl>
<ul><li> <code>content</code>
</li></ul>
<dl><dd> for the context of <a href="#content_by_lua">content_by_lua</a> or <a href="#content_by_lua_file">content_by_lua_file</a>.
</dd></dl>
<ul><li> <code>header_filter</code>
</li></ul>
<dl><dd> for the context of <a href="#header_filter_by_lua">header_filter_by_lua</a> or <a href="#header_filter_by_lua_file">header_filter_by_lua_file</a>.
</dd></dl>
<ul><li> <code>body_filter</code>
</li></ul>
<dl><dd> for the context of <a href="#body_filter_by_lua">body_filter_by_lua</a> or <a href="#body_filter_by_lua_file">body_filter_by_lua_file</a>.
</dd></dl>
<ul><li> <code>log</code>
</li></ul>
<dl><dd> for the context of <a href="#log_by_lua">log_by_lua</a> or <a href="#log_by_lua_file">log_by_lua_file</a>.
</dd></dl>
<ul><li> <code>timer</code>
</li></ul>
<dl><dd> for the context of user callback functions for <a href="#ngx.timer.at">ngx.timer.*</a>.
</dd></dl>
<p>This API was first introduced in the <code>v0.5.10</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=149" title="Edit section: ngx.thread.spawn">edit</a>]</span> <span class="mw-headline" id="ngx.thread.spawn"> ngx.thread.spawn </span></h2>
<p><b>syntax:</b> <i>co = ngx.thread.spawn(func, arg1, arg2, ...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Spawns a new user "light thread" with the Lua function <code>func</code> as well as those optional arguments <code>arg1</code>, <code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine) object represents this "light thread".
</p><p>"Light threads" are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.
</p><p>Before <code>ngx.thread.spawn</code> returns, the <code>func</code> will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a> (like <a href="#tcpsock:receive">tcpsock:receive</a>).
</p><p>After <code>ngx.thread.spawn</code> returns, the newly-created "light thread" will keep running asynchronously usually at various I/O events.
</p><p>All the Lua code chunks running by <a href="#rewrite_by_lua">rewrite_by_lua</a>, <a href="#access_by_lua">access_by_lua</a>, and <a href="#content_by_lua">content_by_lua</a> are in a boilerplate "light thread" created automatically by ngx_lua. Such boilerplate "light thread" are also called "entry threads".
</p><p>By default, the corresponding Nginx handler (e.g., <a href="#rewrite_by_lua">rewrite_by_lua</a> handler) will not terminate until
</p>
<ol><li> both the "entry thread" and all the user "light threads" terminates,
</li><li> a "light thread" (either the "entry thread" or a user "light thread" aborts by calling <a href="#ngx.exit">ngx.exit</a>, <a href="#ngx.exec">ngx.exec</a>, <a href="#ngx.redirect">ngx.redirect</a>, or <a href="#ngx.req.set_uri">ngx.req.set_uri(uri, true)</a>, or
</li><li> the "entry thread" terminates with a Lua error.
</li></ol>
<p>When the user "light thread" terminates with a Lua error, however, it will not abort other running "light threads" like the "entry thread" does.
</p><p>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running "light thread" that is pending on one ore more Nginx subrequests. You must call <a href="#ngx.thread.wait">ngx.thread.wait</a> to wait for those "light thread" to terminate before quitting the "world". A notable exception here is that you can abort pending subrequests by calling <a href="#ngx.exit">ngx.exit</a> with and only with the status code <code>ngx.ERROR</code> (-1), <code>408</code>, <code>444</code>, or <code>499</code>.
</p><p>The "light threads" are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A "light thread" will keep running exclusively on the CPU until
</p>
<ol><li> a (nonblocking) I/O operation cannot be completed in a single run,
</li><li> it calls <a href="#coroutine.yield">coroutine.yield</a> to actively give up execution, or
</li><li> it is aborted by a Lua error or an invocation of <a href="#ngx.exit">ngx.exit</a>, <a href="#ngx.exec">ngx.exec</a>, <a href="#ngx.redirect">ngx.redirect</a>, or <a href="#ngx.req.set_uri">ngx.req.set_uri(uri, true)</a>.
</li></ol>
<p>For the first two cases, the "light thread" will usually be resumed later by the ngx_lua scheduler unless a "stop-the-world" event happens.
</p><p>User "light threads" can create "light threads" themselves and normal user coroutiens created by <a href="#coroutine.create">coroutine.create</a> can also create "light threads". The coroutine (be it a normal Lua coroutine or a "light thread") that directly spawns the "light thread" is called the "parent coroutine" for the "light thread" newly spawned.
</p><p>The "parent coroutine" can call <a href="#ngx.thread.wait">ngx.thread.wait</a> to wait on the termination of its child "light thread".
</p><p>You can call coroutine.status() and coroutine.yield() on the "light thread" coroutines.
</p><p>The status of the "light thread" coroutine can be "zombie" if
</p>
<ol><li> the current "light thread" already terminates (either successfully or with an error),
</li><li> its parent coroutine is still alive, and
</li><li> its parent coroutine is not waiting on it with <a href="#ngx.thread.wait">ngx.thread.wait</a>.
</li></ol>
<p>The following example demonstrates the use of coroutine.yield() in the "light thread" coroutines
to do manual time-slicing:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> yield <span class="sy0">=</span> <span class="kw1">coroutine.yield</span>
&nbsp;
    <span class="kw1">function</span> f<span class="br0">(</span><span class="br0">)</span>
        <span class="kw1">local</span> self <span class="sy0">=</span> <span class="kw1">coroutine</span>.running<span class="br0">(</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"f 1"</span><span class="br0">)</span>
        yield<span class="br0">(</span>self<span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"f 2"</span><span class="br0">)</span>
        yield<span class="br0">(</span>self<span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"f 3"</span><span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> self <span class="sy0">=</span> <span class="kw1">coroutine</span>.running<span class="br0">(</span><span class="br0">)</span>
    ngx.say<span class="br0">(</span><span class="st0">"0"</span><span class="br0">)</span>
    yield<span class="br0">(</span>self<span class="br0">)</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"1"</span><span class="br0">)</span>
    ngx.thread.spawn<span class="br0">(</span>f<span class="br0">)</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"2"</span><span class="br0">)</span>
    yield<span class="br0">(</span>self<span class="br0">)</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"3"</span><span class="br0">)</span>
    yield<span class="br0">(</span>self<span class="br0">)</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"4"</span><span class="br0">)</span></pre></div></div>
<p>Then it will generate the output
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    0
    1
    f 1
    2
    f 2
    3
    f 3
    4</pre></div></div>
<p>"Light threads" are mostly useful for doing concurrent upstream requests in a single Nginx request handler, kinda like a generalized version of <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> that can work with all the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a>. The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (very much like the Facebook BigPipe model):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- query mysql, memcached, and a remote http service at the same time,</span>
    <span class="co1">-- output the results in the order that they</span>
    <span class="co1">-- actually return the results.</span>
&nbsp;
    <span class="kw1">local</span> mysql <span class="sy0">=</span> <span class="kw1">require</span> <span class="st0">"resty.mysql"</span>
    <span class="kw1">local</span> memcached <span class="sy0">=</span> <span class="kw1">require</span> <span class="st0">"resty.memcached"</span>
&nbsp;
    <span class="kw1">local</span> <span class="kw1">function</span> query_mysql<span class="br0">(</span><span class="br0">)</span>
        <span class="kw1">local</span> db <span class="sy0">=</span> mysql:new<span class="br0">(</span><span class="br0">)</span>
        db:connect<span class="br0">{</span>
                    host <span class="sy0">=</span> <span class="st0">"127.0.0.1"</span>,
                    port <span class="sy0">=</span> <span class="nu0">3306</span>,
                    database <span class="sy0">=</span> <span class="st0">"test"</span>,
                    user <span class="sy0">=</span> <span class="st0">"monty"</span>,
                    password <span class="sy0">=</span> <span class="st0">"mypass"</span>
                  <span class="br0">}</span>
        <span class="kw1">local</span> res, err, errno, sqlstate <span class="sy0">=</span>
                db:query<span class="br0">(</span><span class="st0">"select * from cats order by id asc"</span><span class="br0">)</span>
        db:set_keepalive<span class="br0">(</span><span class="nu0">0</span>, <span class="nu0">100</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"mysql done: "</span>, cjson.encode<span class="br0">(</span>res<span class="br0">)</span><span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> <span class="kw1">function</span> query_memcached<span class="br0">(</span><span class="br0">)</span>
        <span class="kw1">local</span> memc <span class="sy0">=</span> memcached:new<span class="br0">(</span><span class="br0">)</span>
        memc:connect<span class="br0">(</span><span class="st0">"127.0.0.1"</span>, <span class="nu0">11211</span><span class="br0">)</span>
        <span class="kw1">local</span> res, err <span class="sy0">=</span> memc:get<span class="br0">(</span><span class="st0">"some_key"</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"memcached done: "</span>, res<span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> <span class="kw1">function</span> query_http<span class="br0">(</span><span class="br0">)</span>
        <span class="kw1">local</span> res <span class="sy0">=</span> ngx.location.capture<span class="br0">(</span><span class="st0">"/my-http-proxy"</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"http done: "</span>, res.body<span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    ngx.thread.spawn<span class="br0">(</span>query_mysql<span class="br0">)</span>      <span class="co1">-- create thread 1</span>
    ngx.thread.spawn<span class="br0">(</span>query_memcached<span class="br0">)</span>  <span class="co1">-- create thread 2</span>
    ngx.thread.spawn<span class="br0">(</span>query_http<span class="br0">)</span>       <span class="co1">-- create thread 3</span></pre></div></div>
<p>This API was first enabled in the <code>v0.7.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=150" title="Edit section: ngx.thread.wait">edit</a>]</span> <span class="mw-headline" id="ngx.thread.wait"> ngx.thread.wait </span></h2>
<p><b>syntax:</b> <i>ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Waits on one or more child "light threads" and returns the results of the first "light thread" that terminates (either successfully or with an error).
</p><p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of <a href="#ngx.thread.spawn">ngx.thread.spawn</a>.
</p><p>The return values have exactly the same meaning as <a href="#coroutine.resume">coroutine.resume</a>, that is, the first value returned is a boolean value indicating whether the "light thread" terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the "light thread" (in case of success) or the error object (in case of failure).
</p><p>Only the direct "parent coroutine" can wait on its child "light thread", otherwise a Lua exception will be raised.
</p><p>The following example demonstrates the use of <code>ngx.thread.wait</code> and <a href="#ngx.location.capture">ngx.location.capture</a> to emulate <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> capture <span class="sy0">=</span> ngx.location.capture
    <span class="kw1">local</span> spawn <span class="sy0">=</span> ngx.thread.spawn
    <span class="kw1">local</span> wait <span class="sy0">=</span> ngx.thread.wait
    <span class="kw1">local</span> say <span class="sy0">=</span> ngx.say
&nbsp;
    <span class="kw1">local</span> <span class="kw1">function</span> fetch<span class="br0">(</span>uri<span class="br0">)</span>
        <span class="kw1">return</span> capture<span class="br0">(</span>uri<span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> threads <span class="sy0">=</span> <span class="br0">{</span>
        spawn<span class="br0">(</span>fetch, <span class="st0">"/foo"</span><span class="br0">)</span>,
        spawn<span class="br0">(</span>fetch, <span class="st0">"/bar"</span><span class="br0">)</span>,
        spawn<span class="br0">(</span>fetch, <span class="st0">"/baz"</span><span class="br0">)</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span>, #threads <span class="kw1">do</span>
        <span class="kw1">local</span> ok, res <span class="sy0">=</span> wait<span class="br0">(</span>threads<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
        <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
            say<span class="br0">(</span>i, <span class="st0">": failed to run: "</span>, res<span class="br0">)</span>
        <span class="kw1">else</span>
            say<span class="br0">(</span>i, <span class="st0">": status: "</span>, res.status<span class="br0">)</span>
            say<span class="br0">(</span>i, <span class="st0">": body: "</span>, res.body<span class="br0">)</span>
        <span class="kw1">end</span>
    <span class="kw1">end</span></pre></div></div>
<p>Here it essentially implements the "wait all" model.
</p><p>And below is an example demonstrating the "wait any" model:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">function</span> f<span class="br0">(</span><span class="br0">)</span>
        ngx.sleep<span class="br0">(</span><span class="nu0">0.2</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"f: hello"</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="st0">"f done"</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">function</span> g<span class="br0">(</span><span class="br0">)</span>
        ngx.sleep<span class="br0">(</span><span class="nu0">0.1</span><span class="br0">)</span>
        ngx.say<span class="br0">(</span><span class="st0">"g: hello"</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="st0">"g done"</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> tf, err <span class="sy0">=</span> ngx.thread.spawn<span class="br0">(</span>f<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> tf <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to spawn thread f: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"f thread created: "</span>, <span class="kw1">coroutine.status</span><span class="br0">(</span>tf<span class="br0">)</span><span class="br0">)</span>
&nbsp;
    <span class="kw1">local</span> tg, err <span class="sy0">=</span> ngx.thread.spawn<span class="br0">(</span>g<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> tg <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to spawn thread g: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"g thread created: "</span>, <span class="kw1">coroutine.status</span><span class="br0">(</span>tg<span class="br0">)</span><span class="br0">)</span>
&nbsp;
    ok, res <span class="sy0">=</span> ngx.thread.wait<span class="br0">(</span>tf, tg<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        ngx.say<span class="br0">(</span><span class="st0">"failed to wait: "</span>, res<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span>
&nbsp;
    ngx.say<span class="br0">(</span><span class="st0">"res: "</span>, res<span class="br0">)</span>
&nbsp;
    <span class="co1">-- stop the "world", aborting other running threads</span>
    ngx.<span class="kw1">exit</span><span class="br0">(</span>ngx.OK<span class="br0">)</span></pre></div></div>
<p>And it will generate the following output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    f thread created: running
    g thread created: running
    g: hello
    res: g done</pre></div></div>
<p>This API was first enabled in the <code>v0.7.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=151" title="Edit section: ngx.on abort">edit</a>]</span> <span class="mw-headline" id="ngx.on_abort"> ngx.on_abort </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.on_abort(callback)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*</i>
</p><p>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.
</p><p>Returns <code>1</code> if the callback is registered successfully or returns <code>nil</code> and a string describing the error otherwise.
</p><p>All the <a href="#Nginx_API_for_Lua">Nginx API for Lua</a> can be used in the callback function because the function is run in a special "light thread", just as those "light threads" created by <a href="#ngx.thread.spawn">ngx.thread.spawn</a>.
</p><p>The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling <a href="#ngx.exit">ngx.exit</a>, for example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> <span class="kw1">function</span> my_cleanup<span class="br0">(</span><span class="br0">)</span>
        <span class="co1">-- custom cleanup work goes here, like cancelling a pending DB transaction</span>
&nbsp;
        <span class="co1">-- now abort all the "light threads" running in the current request handler</span>
        ngx.<span class="kw1">exit</span><span class="br0">(</span><span class="nu0">499</span><span class="br0">)</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> ngx.on_abort<span class="br0">(</span>my_cleanup<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"failed to register the on_abort callback: "</span>, err<span class="br0">)</span>
        ngx.<span class="kw1">exit</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span>
    <span class="kw1">end</span></pre></div></div>
<p>When <a href="#lua_check_client_abort">lua_check_client_abort</a> is set to <code>off</code> (which is the default), then this function call will always return the error message "lua_check_client_abort is off".
</p><p>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message "duplicate call".
</p><p>This API was first introduced in the <code>v0.7.4</code> release.
</p><p>See also <a href="#lua_check_client_abort">lua_check_client_abort</a>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=152" title="Edit section: ngx.timer.at">edit</a>]</span> <span class="mw-headline" id="ngx.timer.at"> ngx.timer.at </span></h2>
<p><b>syntax:</b> <i>ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>Creates an Nginx timer with a user callback function as well as optional user arguments.
</p><p>The first argument, <code>delay</code>, specifies the delay for the timer,
in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1
millisecond here. <code>0</code> delay can also be specified, in which case the
timer will immediately expire when the current handler yields
execution.
</p><p>The second argument, <code>callback</code>, can
be any Lua function, which will be invoked later in a background
"light thread" after the delay specified. The user callback will be
called automatically by the Nginx core with the arguments <code>premature</code>,
<code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code>
argument takes a boolean value indicating whether it is a premature timer
expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are
those (extra) user arguments specified when calling <code>ngx.timer.at</code>
as the remaining arguments.
</p><p>Premature timer expiration happens when the Nginx worker process is
trying to shut down, as in an Nginx configuration reload triggered by
the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker
is trying to shut down, one can no longer call <code>ngx.timer.at</code> to
create new timers and in that case <code>ngx.timer.at</code> will return <code>nil</code> and
a string describing the error, that is, "process exiting".
</p><p>When a timer expires, the user Lua code in the timer callback is
running in a "light thread" detached completely from the original
request creating the timer. So objects with the same lifetime as the
request creating them, like <a href="#ngx.socket.tcp">cosockets</a>, cannot be shared between the
original request and the timer user callback function.
</p><p>Here is a simple example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> / <span class="br0">{</span>
        ...
        log_by_lua <span class="st0">'
            local function push_data(premature, uri, args, status)
                -- push the data uri, args, and status to the remote
                -- via ngx.socket.tcp or ngx.socket.udp
                -- (one may want to buffer the data in Lua a bit to
                -- save I/O operations)
            end
            local ok, err = ngx.timer.at(0, push_data,
                                         ngx.var.uri, ngx.var.args, ngx.header.status)
            if not ok then
                ngx.log(ngx.ERR, "failed to create timer: ", err)
                return
            end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>One can also create infinite re-occuring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> delay <span class="sy0">=</span> <span class="nu0">5</span>
    <span class="kw1">local</span> handler
    handler <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">(</span>premature<span class="br0">)</span>
        <span class="co1">-- do some routine job in Lua just like a cron job</span>
        <span class="kw1">if</span> premature <span class="kw1">then</span>
            <span class="kw1">return</span>
        <span class="kw1">end</span>
        <span class="kw1">local</span> ok, err <span class="sy0">=</span> ngx.timer.at<span class="br0">(</span>delay, handler<span class="br0">)</span>
        <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
            ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"failed to create the timer: "</span>, err<span class="br0">)</span>
            <span class="kw1">return</span>
        <span class="kw1">end</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">local</span> ok, err <span class="sy0">=</span> ngx.timer.at<span class="br0">(</span>delay, handler<span class="br0">)</span>
    <span class="kw1">if</span> <span class="kw1">not</span> ok <span class="kw1">then</span>
        ngx.<span class="kw1">log</span><span class="br0">(</span>ngx.ERR, <span class="st0">"failed to create the timer: "</span>, err<span class="br0">)</span>
        <span class="kw1">return</span>
    <span class="kw1">end</span></pre></div></div>
<p>Because timer callbacks run in the background and their running time
will not add to any client request's response time, they can easily
accumulate in the server and exhaust system resources due to either
Lua programming mistakes or just too much client traffic. To prevent
extreme consequences like crashing the Nginx server, there are
built-in limitations on both the number of "pending timers" and the
number of "running timers" in an Nginx worker process. The "pending
timers" here mean timers that have not yet been expired and "running
timers" are those whose user callbacks are currently running.
</p><p>The maximal number of pending timers allowed in an Nginx
worker is constrolled by the <a href="#lua_max_pending_timers">lua_max_pending_timers</a>
directive. The maximal number of running timers is controlled by the
<a href="#lua_max_running_timers">lua_max_running_timers</a> directive.
</p><p>According to the current implementation, each "running timer" will
take one (fake) connection record from the global connection record
list configured by the standard <a href="/EventsModule#worker_connections" title="EventsModule">worker_connections</a> directive in
<code>nginx.conf</code>. So ensure that the
<a href="/EventsModule#worker_connections" title="EventsModule">worker_connections</a> directive is set to
a large enough value that takes into account both the real connections
and fake connections required by timer callbacks (as limited by the
<a href="#lua_max_running_timers">lua_max_running_timers</a> directive).
</p><p>A lot of the Lua APIs for Nginx are enabled in the context of the timer
callbacks, like stream/datagram cosockets (<a href="#ngx.socket.tcp">ngx.socket.tcp</a> and <a href="#ngx.socket.udp">ngx.socket.udp</a>), shared
memory dictionaries (<a href="#ngx.shared.DICT">ngx.shared.DICT</a>), user coroutines (<a href="#coroutine.create">coroutine.*</a>),
user "light threads" (<a href="#ngx.thread.spawn">ngx.thread.*</a>), <a href="#ngx.exit">ngx.exit</a>, <a href="#ngx.now">ngx.now</a>/<a href="#ngx.time">ngx.time</a>,
<a href="#ngx.md5">ngx.md5</a>/<a href="#ngx.sha1_bin">ngx.sha1_bin</a>, are all allowed. But the subrequest API (like
<a href="#ngx.location.capture">ngx.location.capture</a>), the <a href="#ngx.req.start_time">ngx.req.*</a> API, the downstream output API
(like <a href="#ngx.say">ngx.say</a>, <a href="#ngx.print">ngx.print</a>, and <a href="#ngx.flush">ngx.flush</a>) are explicitly disabled in
this context.
</p><p>This API was first introduced in the <code>v0.8.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=153" title="Edit section: ngx.config.debug">edit</a>]</span> <span class="mw-headline" id="ngx.config.debug"> ngx.config.debug </span></h2>
<p><b>syntax:</b> <i>debug = ngx.config.debug</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</i>
</p><p>This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the <code>./configure</code> option <code>--with-debug</code>.
</p><p>This field was first introduced in the <code>0.8.7</code>.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=154" title="Edit section: ndk.set var.DIRECTIVE">edit</a>]</span> <span class="mw-headline" id="ndk.set_var.DIRECTIVE"> ndk.set_var.DIRECTIVE </span></h2>
<p><b>syntax:</b> <i>res = ndk.set_var.DIRECTIVE_NAME</i>
</p><p><b>context:</b> <i>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*</i>
</p><p>This mechanism allows calling other nginx C modules' directives that are implemented by <a rel="nofollow" class="external text" href="https://github.com/simpl/ngx_devel_kit">Nginx Devel Kit</a> (NDK)'s set_var submodule's <code>ndk_set_var_value</code>.
</p><p>For example, the following <a href="/HttpSetMiscModule" title="HttpSetMiscModule">HttpSetMiscModule</a> directives can be invoked this way:
</p>
<ul><li> <a href="/HttpSetMiscModule#set_quote_sql_str" title="HttpSetMiscModule">set_quote_sql_str</a>
</li><li> <a href="/HttpSetMiscModule#set_quote_pgsql_str" title="HttpSetMiscModule">set_quote_pgsql_str</a>
</li><li> <a href="/HttpSetMiscModule#set_quote_json_str" title="HttpSetMiscModule">set_quote_json_str</a>
</li><li> <a href="/HttpSetMiscModule#set_unescape_uri" title="HttpSetMiscModule">set_unescape_uri</a>
</li><li> <a href="/HttpSetMiscModule#set_escape_uri" title="HttpSetMiscModule">set_escape_uri</a>
</li><li> <a href="/HttpSetMiscModule#set_encode_base32" title="HttpSetMiscModule">set_encode_base32</a>
</li><li> <a href="/HttpSetMiscModule#set_decode_base32" title="HttpSetMiscModule">set_decode_base32</a>
</li><li> <a href="/HttpSetMiscModule#set_encode_base64" title="HttpSetMiscModule">set_encode_base64</a>
</li><li> <a href="/HttpSetMiscModule#set_decode_base64" title="HttpSetMiscModule">set_decode_base64</a>
</li><li> <a href="/HttpSetMiscModule#set_encode_base64" title="HttpSetMiscModule">set_encode_hex</a>
</li><li> <a href="/HttpSetMiscModule#set_decode_base64" title="HttpSetMiscModule">set_decode_hex</a>
</li><li> <a href="/HttpSetMiscModule#set_encode_base64" title="HttpSetMiscModule">set_sha1</a>
</li><li> <a href="/HttpSetMiscModule#set_decode_base64" title="HttpSetMiscModule">set_md5</a>
</li></ul>
<p>For instance,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> res <span class="sy0">=</span> ndk.set_var.set_escape_uri<span class="br0">(</span><span class="st0">'a/b'</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">-- now res == 'a%2fb'</span></pre></div></div>
<p>Similarly, the following directives provided by <a href="/HttpEncryptedSessionModule" title="HttpEncryptedSessionModule">HttpEncryptedSessionModule</a> can be invoked from within Lua too:
</p>
<ul><li> <a href="/HttpEncryptedSessionModule#set_encrypt_session" title="HttpEncryptedSessionModule">set_encrypt_session</a>
</li><li> <a href="/HttpEncryptedSessionModule#set_decrypt_session" title="HttpEncryptedSessionModule">set_decrypt_session</a>
</li></ul>
<p>This feature requires the <a rel="nofollow" class="external text" href="https://github.com/simpl/ngx_devel_kit">ngx_devel_kit</a> module.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=155" title="Edit section: coroutine.create">edit</a>]</span> <span class="mw-headline" id="coroutine.create"> coroutine.create </span></h2>
<p><b>syntax:</b> <i>co = coroutine.create(f)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.
</p><p>Similar to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create">coroutine.create</a> API, but works in the context of the Lua coroutines created by ngx_lua.
</p><p>This API was first introduced in the <code>v0.6.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=156" title="Edit section: coroutine.resume">edit</a>]</span> <span class="mw-headline" id="coroutine.resume"> coroutine.resume </span></h2>
<p><b>syntax:</b> <i>ok, ... = coroutine.resume(co, ...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Resumes the executation of a user Lua coroutine object previously yielded or just created.
</p><p>Similar to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume">coroutine.resume</a> API, but works in the context of the Lua coroutines created by ngx_lua.
</p><p>This API was first introduced in the <code>v0.6.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=157" title="Edit section: coroutine.yield">edit</a>]</span> <span class="mw-headline" id="coroutine.yield"> coroutine.yield </span></h2>
<p><b>syntax:</b> <i>... = coroutine.yield(co, ...)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Yields the executation of the current user Lua coroutine.
</p><p>Similar to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield">coroutine.yield</a> API, but works in the context of the Lua coroutines created by ngx_lua.
</p><p>This API was first introduced in the <code>v0.6.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=158" title="Edit section: coroutine.wrap">edit</a>]</span> <span class="mw-headline" id="coroutine.wrap"> coroutine.wrap </span></h2>
<p><b>syntax:</b> <i>co = coroutine.wrap(f)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Similar to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap">coroutine.wrap</a> API, but works in the context of the Lua coroutines created by ngx_lua.
</p><p>This API was first introduced in the <code>v0.6.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=159" title="Edit section: coroutine.running">edit</a>]</span> <span class="mw-headline" id="coroutine.running"> coroutine.running </span></h2>
<p><b>syntax:</b> <i>co = coroutine.running()</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Identical to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running">coroutine.running</a> API.
</p><p>This API was first enabled in the <code>v0.6.0</code> release.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=160" title="Edit section: coroutine.status">edit</a>]</span> <span class="mw-headline" id="coroutine.status"> coroutine.status </span></h2>
<p><b>syntax:</b> <i>status = coroutine.status(co)</i>
</p><p><b>context:</b> <i>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*</i>
</p><p>Identical to the standard Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status">coroutine.status</a> API.
</p><p>This API was first enabled in the <code>v0.6.0</code> release.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=161" title="Edit section: Lua/LuaJIT bytecode support">edit</a>]</span> <span class="mw-headline" id="Lua.2FLuaJIT_bytecode_support"> Lua/LuaJIT bytecode support </span></h1>
<p>As from the <code>v0.5.0rc32</code> release, all <code>*_by_lua_file</code> configure directives (such as <a href="#content_by_lua_file">content_by_lua_file</a>) support loading Lua 5.1 and LuaJIT 2.0 raw bytecode files directly.
</p><p>Please note that the bytecode format used by LuaJIT 2.0 is not compatible with that used by the standard Lua 5.1 interpreter. So if using LuaJIT 2.0 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>luajit<span class="sy0">/</span>bin<span class="sy0">/</span>luajit <span class="re5">-b</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>input_file.lua <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>output_file.luac</pre></div></div>
<p>The <code>-bg</code> option can be used to include debug information in the LuaJIT bytecode file:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>luajit<span class="sy0">/</span>bin<span class="sy0">/</span>luajit <span class="re5">-bg</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>input_file.lua <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>output_file.luac</pre></div></div>
<p>Please refer to the official LuaJIT documentation on the <code>-b</code> option for more details:
</p><p><a rel="nofollow" class="external free" href="http://luajit.org/running.html#opt_b">http://luajit.org/running.html#opt_b</a>
</p><p>Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the <code>luac</code> commandline utility as shown:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    luac <span class="re5">-o</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>output_file.luac <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>input_file.lua</pre></div></div>
<p>Unlike as with LuaJIT, debug information is included in standard Lua 5.1 bytecode files by default. This can be striped out by specifying the <code>-s</code> option as shown:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    luac <span class="re5">-s</span> <span class="re5">-o</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>output_file.luac <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>input_file.lua</pre></div></div>
<p>Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0 or vice versa, will result in an error message, such as that below, being logged into the Nginx <code>error.log</code> file:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    [error] 13909#0: *1 failed to load Lua inlined code: bad byte-code header in /path/to/test_file.luac</pre></div></div>
<p>Loading bytecode files via the Lua primitives like <code>require</code> and <code>dofile</code> should always work as expected.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=162" title="Edit section: HTTP 1.0 support">edit</a>]</span> <span class="mw-headline" id="HTTP_1.0_support"> HTTP 1.0 support </span></h1>
<p>The HTTP 1.0 protocol does not support chunked output and requires an explicit <code>Content-Length</code> header when the response body is not empty in order to support the HTTP 1.0 keep-alive.
So when a HTTP 1.0 request is made and the <a href="#lua_http10_buffering">lua_http10_buffering</a> directive is turned <code>on</code>, ngx_lua will buffer the
output of <a href="#ngx.say">ngx.say</a> and <a href="#ngx.print">ngx.print</a> calls and also postpone sending response headers until all the response body output is received.
At that time ngx_lua can calculate the total length of the body and construct a proper <code>Content-Length</code> header to return to the HTTP 1.0 client.
If the <code>Content-Length</code> response header is set in the running Lua code, however, this buffering will be disabled even if the <a href="#lua_http10_buffering">lua_http10_buffering</a> directive is turned <code>on</code>.
</p><p>For large streaming output responses, it is important to disable the <a href="#lua_http10_buffering">lua_http10_buffering</a> directive to minimise memory usage.
</p><p>Note that common HTTP benchmark tools such as <code>ab</code> and <code>http_load</code> issue HTTP 1.0 requests by default.
To force <code>curl</code> to send HTTP 1.0 requests, use the <code>-0</code> option.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=163" title="Edit section: Data Sharing within an Nginx Worker">edit</a>]</span> <span class="mw-headline" id="Data_Sharing_within_an_Nginx_Worker"> Data Sharing within an Nginx Worker </span></h1>
<p>To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua <code>require</code> builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data). Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.
</p><p>Here is a complete small example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- mydata.lua</span>
    <span class="kw1">local</span> _M <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="kw1">local</span> data <span class="sy0">=</span> <span class="br0">{</span>
        dog <span class="sy0">=</span> <span class="nu0">3</span>,
        cat <span class="sy0">=</span> <span class="nu0">4</span>,
        pig <span class="sy0">=</span> <span class="nu0">5</span>,
    <span class="br0">}</span>
&nbsp;
    <span class="kw1">function</span> _M.get_age<span class="br0">(</span>name<span class="br0">)</span>
        <span class="kw1">return</span> data<span class="br0">[</span>name<span class="br0">]</span>
    <span class="kw1">end</span>
&nbsp;
    <span class="kw1">return</span> _M</pre></div></div>
<p>and then accessing it from <code>nginx.conf</code>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /lua <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local mydata = require "mydata"
            ngx.say(mydata.get_age("dog"))
        '</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<p>The <code>mydata</code> module in this example will only be loaded and run on the first request to the location <code>/lua</code>,
and all subsequent requests to the same nginx worker process will use the reloaded instance of the
module as well as the same copy of the data in it, until a <code>HUP</code> signal is sent to the Nginx master process to force a reload.
This data sharing technique is essential for high performance Lua applications based on this module.
</p><p>Note that this data sharing is on a <i>per-worker</i> basis and not on a <i>per-server</i> basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.
</p><p>If server-wide data sharing is required, then use one or more of the following approaches:
</p>
<ol><li> Use the <a href="#ngx.shared.DICT">ngx.shared.DICT</a> API provided by this module.
</li><li> Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine).
</li><li> Use data storage mechanisms such as <code>memcached</code>, <code>redis</code>, <code>MySQL</code> or <code>PostgreSQL</code>. <a rel="nofollow" class="external text" href="http://openresty.org">The ngx_openresty bundle</a> associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.
</li></ol>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=164" title="Edit section: Known Issues">edit</a>]</span> <span class="mw-headline" id="Known_Issues"> Known Issues </span></h1>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=165" title="Edit section: TCP socket connect operation issues">edit</a>]</span> <span class="mw-headline" id="TCP_socket_connect_operation_issues"> TCP socket connect operation issues </span></h2>
<p>The <a href="#tcpsock:connect">tcpsock:connect</a> method may indicate <code>success</code> despite connection failures such as with <code>Connection Refused</code> errors. 
</p><p>However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation. 
</p><p>This issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=166" title="Edit section: Lua Coroutine Yielding/Resuming">edit</a>]</span> <span class="mw-headline" id="Lua_Coroutine_Yielding.2FResuming"> Lua Coroutine Yielding/Resuming </span></h2>
<ul><li> Lua's <code>dofile</code> builtin is implemented as a C function in both Lua 5.1 and LuaJIT 2.0 and when <a href="#ngx.location.capture">ngx.location.capture</a> is called, <a href="#ngx.exec">ngx.exec</a>, <a href="#ngx.exit">ngx.exit</a> or <a href="#ngx.req.read_body">ngx.req.read_body</a> or similar in the file to be loaded by <code>dofile</code>, a coroutine yield across the C function boundary will be initiated. This however is not normally allowed within ngx_lua and will usually result in error messages like <code>lua handler aborted: runtime error: attempt to yield across C-call boundary</code>. To avoid this, define a real Lua module and use the Lua <code>require</code> builtin instead.
</li><li> As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods <a href="#ngx.location.capture">ngx.location.capture</a>, <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>, <a href="#ngx.redirect">ngx.redirect</a>, <a href="#ngx.exec">ngx.exec</a>, and <a href="#ngx.exit">ngx.exit</a> cannot be used within the context of a Lua <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-pcall">pcall()</a> or <a rel="nofollow" class="external text" href="http://www.lua.org/manual/5.1/manual.html#pdf-xpcall">xpcall()</a> or even the first line of the <code>for ... in ...</code> statement when the standard Lua 5.1 interpreter is used and the <code>attempt to yield across metamethod/C-call boundary</code> error will be produced. Please use LuaJIT 2.0, which supports a fully resumable VM, to avoid this.
</li></ul>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=167" title="Edit section: Lua Variable Scope">edit</a>]</span> <span class="mw-headline" id="Lua_Variable_Scope"> Lua Variable Scope </span></h2>
<p>Care must be taken when importing modules and this form should be used:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">local</span> xxx <span class="sy0">=</span> <span class="kw1">require</span><span class="br0">(</span><span class="st0">'xxx'</span><span class="br0">)</span></pre></div></div>
<dl><dd> instead of the old deprecated form:
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="kw1">require</span><span class="br0">(</span><span class="st0">'xxx'</span><span class="br0">)</span></pre></div></div>
<p>Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the <code>require()</code> built-in in the package.loaded table for later reference, and <code>require()</code> has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler,  and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the <code>nil</code> value.
</p><p>Generally, use of Lua global variables is a really really bad idea in the context of ngx_lua because
</p>
<ol><li> misuse of Lua globals has very bad side effects for concurrent requests when these variables are actually supposed to be local only,
</li><li> Lua global variables require Lua table look-up in the global environment (which is just a Lua table), which is kinda expensive, and
</li><li> some Lua global variable references are just typos, which are hard to debug.
</li></ol>
<p>It's *highly* recommended to always declare them via "local" in the scope that is reasonable.
</p><p>To find out all the uses of Lua global variables in your Lua code, you can run the <a rel="nofollow" class="external text" href="https://github.com/agentzh/nginx-devel-utils/blob/master/lua-releng">lua-releng tool</a> across all your .lua source files:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">$ lua-releng
Checking use of Lua global variables in file lib/foo/bar.lua ...
        1       [1489]  SETGLOBAL       7 -1   &nbsp;; contains
        55      [1506]  GETGLOBAL       7 -3   &nbsp;; setvar
        3       [1545]  GETGLOBAL       3 -4   &nbsp;; varexpand</pre></div></div>
<p>The output says that the line 1489 of file <code>lib/foo/bar.lua</code> writes to a global variable named <code>contains</code>, the line 1506 reads from the global variable <code>setvar</code>, and line 1545 reads the global <code>varexpand</code>.
</p><p>This tool will guarantee that local variables in the Lua module functions are all declared with the <code>local</code> keyword, otherwise a runtime exception will be thrown. It prevents undesirable race conditions while accessing such variables. See <a href="#Data_Sharing_within_an_Nginx_Worker">Data Sharing within an Nginx Worker</a> for the reasons behind this.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=168" title="Edit section: Locations Configured by Subrequest Directives of Other Modules">edit</a>]</span> <span class="mw-headline" id="Locations_Configured_by_Subrequest_Directives_of_Other_Modules"> Locations Configured by Subrequest Directives of Other Modules </span></h2>
<p>The <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> directives cannot capture locations that include the <a href="/HttpEchoModule#echo_location" title="HttpEchoModule">echo_location</a>, <a href="/HttpEchoModule#echo_location_async" title="HttpEchoModule">echo_location_async</a>, <a href="/HttpEchoModule#echo_subrequest" title="HttpEchoModule">echo_subrequest</a>, or <a href="/HttpEchoModule#echo_subrequest_async" title="HttpEchoModule">echo_subrequest_async</a> directives.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /foo <span class="br0">{</span>
        content_by_lua <span class="st0">'
            res = ngx.location.capture("/bar")
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /bar <span class="br0">{</span>
        echo_location /blah<span class="sy0">;</span>
    <span class="br0">}</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /blah <span class="br0">{</span>
        echo <span class="st0">"Success!"</span><span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    $ curl -i <a href="/NginxHttpCoreModule#http"><span class="kw3">http</span></a>://example.com/foo</pre></div></div>
<p>will not work as expected.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=169" title="Edit section: Special PCRE Sequences">edit</a>]</span> <span class="mw-headline" id="Special_PCRE_Sequences"> Special PCRE Sequences </span></h2>
<p>PCRE sequences such as <code>\d</code>, <code>\s</code>, or <code>\w</code>, require special attention because in string literals, the backslash character, <code>\</code>, is stripped out by both the Lua language parser and by the Nginx config file parser before processing. So the following snippet will not work as expected:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <span class="co1"># nginx.conf</span>
   &nbsp;? <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
   &nbsp;?     content_by_lua <span class="st0">'
   &nbsp;?         local regex = "<span class="es0">\d</span>+"  -- THIS IS WRONG!!
   &nbsp;?         local m = ngx.re.match("hello, 1234", regex)
   &nbsp;?         if m then ngx.say(m[0]) else ngx.say("not matched!") end
   &nbsp;?     '</span><span class="sy0">;</span>
   &nbsp;? <span class="br0">}</span>
    <span class="co1"># evaluates to "not matched!"</span></pre></div></div>
<p>To avoid this, <i>double</i> escape the backslash:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <span class="co1"># nginx.conf</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local regex = "<span class="es0">\\</span><span class="es0">\\</span>d+"
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1"># evaluates to "1234"</span></pre></div></div>
<p>Here, <code>\\\\d+</code> is stripped down to <code>\\d+</code> by the Nginx config file parser and this is further stripped down to <code>\d+</code> by the Lua language parser before running.
</p><p>Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in "long brackets", <code>[[...]]</code>, in which case backslashes have to only be escaped once for the Nginx config file parser. 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <span class="co1"># nginx.conf</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local regex = [[<span class="es0">\\</span>d+]]
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1"># evaluates to "1234"</span></pre></div></div>
<p>Here, <code>[[\\d+]]</code> is stripped down to <code>[[\d+]]</code> by the Nginx config file parser and this is processed correctly.
</p><p>Note that a longer from of the long bracket, <code>[=[...]=]</code>, may be required if the regex pattern contains <code>[...]</code> sequences. 
The <code>[=[...]=]</code> form may be used as the default form if desired.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="nginx source-nginx"><pre class="de1">    <span class="co1"># nginx.conf</span>
    <a href="/NginxHttpCoreModule#location"><span class="kw3">location</span></a> /test <span class="br0">{</span>
        content_by_lua <span class="st0">'
            local regex = [=[[0-9]+]=]
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        '</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1"># evaluates to "1234"</span></pre></div></div>
<p>An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various <code>*_by_lua_file</code> directives. 
With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- test.lua</span>
    <span class="kw1">local</span> regex <span class="sy0">=</span> <span class="st0">"<span class="es0">\\</span>d+"</span>
    <span class="kw1">local</span> m <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, 1234"</span>, regex<span class="br0">)</span>
    <span class="kw1">if</span> m <span class="kw1">then</span> ngx.say<span class="br0">(</span>m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span> <span class="kw1">else</span> ngx.say<span class="br0">(</span><span class="st0">"not matched!"</span><span class="br0">)</span> <span class="kw1">end</span>
    <span class="co1">-- evaluates to "1234"</span></pre></div></div>
<p>Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification. 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="lua source-lua"><pre class="de1">    <span class="co1">-- test.lua</span>
    <span class="kw1">local</span> regex <span class="sy0">=</span> <span class="br0">[</span><span class="br0">[</span>\d+<span class="br0">]</span><span class="br0">]</span>
    <span class="kw1">local</span> m <span class="sy0">=</span> ngx.re.match<span class="br0">(</span><span class="st0">"hello, 1234"</span>, regex<span class="br0">)</span>
    <span class="kw1">if</span> m <span class="kw1">then</span> ngx.say<span class="br0">(</span>m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span> <span class="kw1">else</span> ngx.say<span class="br0">(</span><span class="st0">"not matched!"</span><span class="br0">)</span> <span class="kw1">end</span>
    <span class="co1">-- evaluates to "1234"</span></pre></div></div>
<h2><span class="mw-headline" id="Mixing_with_SSI_Not_Supported"> Mixing with SSI Not Supported </span></h2>
<p>Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.
</p>
<h2><span class="mw-headline" id="SPDY_Mode_Not_Fully_Supported"> SPDY Mode Not Fully Supported </span></h2>
<p>Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: <a href="#ngx.location.capture">ngx.location.capture</a>, <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a>, and <a href="#ngx.req.socket">ngx.req.socket</a>.
</p>
<h1><span class="mw-headline" id="Typical_Uses"> Typical Uses </span></h1>
<p>Just to name a few:
</p>
<ul><li> Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
</li><li> doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,
</li><li> manipulating response headers in an arbitrary way (by Lua)
</li><li> fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,
</li><li> coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,
</li><li> doing very complex URL dispatch in Lua at rewrite phase,
</li><li> using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.
</li></ul>
<p>The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.0 is enabled. 
</p><p>Other scripting language implementations typically struggle to match this performance level.
</p><p>The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.
</p><p>On a ThinkPad T400 2.80 GHz laptop, the Hello World example readily achieves 28k req/sec using <code>http_load -p 10</code>. By contrast, Nginx + php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and <a rel="nofollow" class="external text" href="http://nodejs.org/">Node.js</a> v0.6.1 yields 10.2k req/sec for their Hello World equivalents.
</p>
<h1><span class="mw-headline" id="Nginx_Compatibility"> Nginx Compatibility </span></h1>
<p>The latest module is compatible with the following versions of Nginx:
</p>
<ul><li> 1.5.x (last tested: 1.5.4)
</li><li> 1.4.x (last tested: 1.4.2)
</li><li> 1.3.x (last tested: 1.3.11)
</li><li> 1.2.x (last tested: 1.2.9)
</li><li> 1.1.x (last tested: 1.1.5)
</li><li> 1.0.x (last tested: 1.0.15)
</li><li> 0.9.x (last tested: 0.9.4)
</li><li> 0.8.x &gt;= 0.8.54 (last tested: 0.8.54)
</li></ul>
<h1><span class="mw-headline" id="Code_Repository"> Code Repository </span></h1>
<p>The code repository of this project is hosted on github at <a rel="nofollow" class="external text" href="http://github.com/chaoslawful/lua-nginx-module">chaoslawful/lua-nginx-module</a>.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=175" title="Edit section: Installation">edit</a>]</span> <span class="mw-headline" id="Installation"> Installation </span></h1>
<p>The <a rel="nofollow" class="external text" href="http://openresty.org">ngx_openresty bundle</a> can be used to install Nginx, ngx_lua, either one of the standard Lua 5.1 interpreter or LuaJIT 2.0, as well as a package of powerful companion Nginx modules. The basic installation step is a simple <code>./configure --with-luajit &amp;&amp; make &amp;&amp; make install</code>.
</p><p>Alternatively, ngx_lua can be manually compiled into Nginx:
</p>
<ol><li> Install LuaJIT 2.0 (recommended) or Lua 5.1 (Lua 5.2 is <i>not</i> supported yet). LuajIT can be downloaded from the <a rel="nofollow" class="external text" href="http://luajit.org/download.html">the LuaJIT project website</a> and Lua 5.1, from the <a rel="nofollow" class="external text" href="http://www.lua.org/">Lua project website</a>.  Some distribution package managers also distribute LuajIT and/or Lua.
</li><li> Download the latest version of the ngx_devel_kit (NDK) module <a rel="nofollow" class="external text" href="http://github.com/simpl/ngx_devel_kit/tags">HERE</a>.
</li><li> Download the latest version of ngx_lua <a rel="nofollow" class="external text" href="http://github.com/chaoslawful/lua-nginx-module/tags">HERE</a>.
</li><li> Download the latest version of Nginx <a rel="nofollow" class="external text" href="http://nginx.org/">HERE</a> (See <a href="#Nginx_Compatibility">Nginx Compatibility</a>)
</li></ol>
<p>Build the source with this module:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">    <span class="kw2">wget</span> <span class="st_h">'http://nginx.org/download/nginx-1.4.2.tar.gz'</span>
    <span class="kw2">tar</span> <span class="re5">-xzvf</span> nginx-1.4.2.tar.gz
    <span class="kw3">cd</span> nginx-1.4.2<span class="sy0">/</span>
&nbsp;
    <span class="co0"># tell nginx's build system where to find LuaJIT:</span>
    <span class="kw3">export</span> <span class="re2">LUAJIT_LIB</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>luajit<span class="sy0">/</span>lib
    <span class="kw3">export</span> <span class="re2">LUAJIT_INC</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>luajit<span class="sy0">/</span>include<span class="sy0">/</span>luajit-<span class="nu0">2.0</span>
&nbsp;
    <span class="co0"># or tell where to find Lua if using Lua instead:</span>
    <span class="co0">#export LUA_LIB=/path/to/lua/lib</span>
    <span class="co0">#export LUA_INC=/path/to/lua/include</span>
&nbsp;
    <span class="co0"># Here we assume Nginx is to be installed under /opt/nginx/.</span>
    .<span class="sy0">/</span>configure <span class="re5">--prefix</span>=<span class="sy0">/</span>opt<span class="sy0">/</span>nginx \
            <span class="re5">--add-module</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>ngx_devel_kit \
            <span class="re5">--add-module</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>lua-nginx-module
&nbsp;
    <span class="kw2">make</span> <span class="re5">-j2</span>
    <span class="kw2">make</span> <span class="kw2">install</span></pre></div></div>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=176" title="Edit section: Installation on Ubuntu 11.10">edit</a>]</span> <span class="mw-headline" id="Installation_on_Ubuntu_11.10"> Installation on Ubuntu 11.10 </span></h2>
<p>Note that it is recommended to use LuaJIT 2.0 instead of the standard Lua 5.1 interpreter where possible. 
</p><p>If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="kw2">apt-get</span> <span class="kw2">install</span> <span class="re5">-y</span> lua5.1 liblua5.1-<span class="nu0">0</span> liblua5.1-<span class="nu0">0</span>-dev</pre></div></div>
<p>Everything should be installed correctly, except for one small tweak. 
</p><p>Library name <code>liblua.so</code> has been changed in liblua5.1 package, it only comes with <code>liblua5.1.so</code>, which needs to be symlinked to <code>/usr/lib</code> so it could be found during the configuration process.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="kw2">ln</span> <span class="re5">-s</span> <span class="sy0">/</span>usr<span class="sy0">/</span>lib<span class="sy0">/</span>x86_64-linux-gnu<span class="sy0">/</span>liblua5.1.so <span class="sy0">/</span>usr<span class="sy0">/</span>lib<span class="sy0">/</span>liblua.so</pre></div></div>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=177" title="Edit section: Community">edit</a>]</span> <span class="mw-headline" id="Community"> Community </span></h1>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=178" title="Edit section: English Mailing List">edit</a>]</span> <span class="mw-headline" id="English_Mailing_List"> English Mailing List </span></h2>
<p>The <a rel="nofollow" class="external text" href="https://groups.google.com/group/openresty-en">openresty-en</a> mailing list is for English speakers.
</p>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=179" title="Edit section: Chinese Mailing List">edit</a>]</span> <span class="mw-headline" id="Chinese_Mailing_List"> Chinese Mailing List </span></h2>
<p>The <a rel="nofollow" class="external text" href="https://groups.google.com/group/openresty">openresty</a> mailing list is for Chinese speakers.
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=180" title="Edit section: Bugs and Patches">edit</a>]</span> <span class="mw-headline" id="Bugs_and_Patches"> Bugs and Patches </span></h1>
<p>Please submit bug reports, wishlists, or patches by
</p>
<ol><li> creating a ticket on the <a rel="nofollow" class="external text" href="http://github.com/chaoslawful/lua-nginx-module/issues">GitHub Issue Tracker</a>,
</li><li> or posting to the <a href="#Community">OpenResty community</a>.
</li></ol>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=181" title="Edit section: TODO">edit</a>]</span> <span class="mw-headline" id="TODO"> TODO </span></h1>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=182" title="Edit section: Short Term">edit</a>]</span> <span class="mw-headline" id="Short_Term"> Short Term </span></h2>
<ul><li> review and apply Brian Akin's patch for the new directive <code>lua_socket_log_errors</code>.
</li><li> review and apply Brian Akin's patch for the new <code>shdict:flush_expired()</code> API.
</li><li> implement the SSL cosocket API.
</li><li> review and apply Jader H. Silva's patch for <code>ngx.re.split()</code>.
</li><li> review and apply vadim-pavlov's patch for <a href="#ngx.location.capture">ngx.location.capture</a>'s <code>extra_headers</code> option
</li><li> use <code>ngx_hash_t</code> to optimize the built-in header look-up process for <a href="#ngx.req.set_header">ngx.req.set_header</a>, <a href="#ngx.header.HEADER">ngx.header.HEADER</a>, and etc.
</li><li> add configure options for different strategies of handling the cosocket connection exceeding in the pools.
</li><li> add directives to run Lua codes when nginx stops.
</li><li> add APIs to access cookies as key/value pairs.
</li><li> add <code>ignore_resp_headers</code>, <code>ignore_resp_body</code>, and <code>ignore_resp</code> options to <a href="#ngx.location.capture">ngx.location.capture</a> and <a href="#ngx.location.capture_multi">ngx.location.capture_multi</a> methods, to allow micro performance tuning on the user side.
</li><li> implement new directive <code>lua_ignore_client_abort</code>.
</li></ul>
<h2><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=183" title="Edit section: Longer Term">edit</a>]</span> <span class="mw-headline" id="Longer_Term"> Longer Term </span></h2>
<ul><li> add lightweight thread API (i.e., the <code>ngx.thread</code> API) as demonstrated in <a rel="nofollow" class="external text" href="http://agentzh.org/misc/nginx/lua-thread2.lua">this sample code</a>.
</li><li> add automatic Lua code time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.
</li><li> add <code>stat</code> mode similar to <a rel="nofollow" class="external text" href="http://httpd.apache.org/docs/2.3/mod/mod_lua.html">mod_lua</a>.
</li></ul>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=184" title="Edit section: Changes">edit</a>]</span> <span class="mw-headline" id="Changes"> Changes </span></h1>
<p>The changes of every release of this module can be obtained from the ngx_openresty bundle's change logs:
</p><p><a rel="nofollow" class="external free" href="http://openresty.org/#Changes">http://openresty.org/#Changes</a>
</p>
<h1><span class="editsection">[<a href="/index.php?title=HttpLuaModule&amp;action=edit&amp;section=185" title="Edit section: Test Suite">edit</a>]</span> <span class="mw-headline" id="Test_Suite"> Test Suite </span></h1>
<p>The following dependencies are required to run the test suite:
</p>
<ul><li> Nginx version &gt;= 1.4.2
</li></ul>
<ul><li> Perl modules:
<ul><li> Test::Nginx: <a rel="nofollow" class="external free" href="http://github.com/agentzh/test-nginx">http://github.com/agentzh/test-nginx</a> 
</li></ul>
</li></ul>
<ul><li> Nginx modules:
<ul><li> <a rel="nofollow" class="external text" href="https://github.com/simpl/ngx_devel_kit">ngx_devel_kit</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/set-misc-nginx-module">ngx_set_misc</a>
</li><li> <a rel="nofollow" class="external text" href="http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz">ngx_auth_request</a> (this is not needed if you're using Nginx 1.5.4+.
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/echo-nginx-module">ngx_echo</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/memc-nginx-module">ngx_memc</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/srcache-nginx-module">ngx_srcache</a>
</li><li> ngx_lua (i.e., this module)
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/headers-more-nginx-module">ngx_headers_more</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/chaoslawful/drizzle-nginx-module">ngx_drizzle</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/rds-json-nginx-module">ngx_rds_json</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/FRiCKLE/ngx_coolkit">ngx_coolkit</a>
</li><li> <a rel="nofollow" class="external text" href="http://github.com/agentzh/redis2-nginx-module">ngx_redis2</a>
</li></ul>
</li></ul>
<p>The order in which these modules are added during configuration is important because the position of any filter module in the
filtering chain determines the final output, for example. The correct adding order is shown above.
</p>
<ul><li> 3rd-party Lua libraries:
<ul><li> <a rel="nofollow" class="external text" href="http://www.kyne.com.au/~mark/software/lua-cjson.php">lua-cjson</a>
</li></ul>
</li></ul>
<ul><li> Applications:
<ul><li> mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
</li><li> memcached: listening on the default port, 11211.
</li><li> redis: listening on the default port, 6379.
</li></ul>
</li></ul>
<p>See also the <a rel="nofollow" class="external text" href="https://github.com/chaoslawful/lua-nginx-module/blob/master/util/build2.sh">developer build script</a> for more details on setting up the testing environment.
</p><p>To run the whole test suite in the default testing mode:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    cd /path/to/lua-nginx-module
    export PATH=/path/to/your/nginx/sbin:$PATH
    prove -I/path/to/test-nginx/lib -r t</pre></div></div>
<p>To run specific test files:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">    cd /path/to/lua-nginx-module
    export PATH=/path/to/your/nginx/sbin:$PATH
    prove -I/path/to/test-nginx/lib t/002-content.t t/003-errors.t</pre></div></div>
<p>To run a specific test block in a particular test file, add the line <code>--- ONLY</code> to the test block you want to run, and then use the `prove` utility to run that <code>.t</code> file.
</p><p>There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the <a rel="nofollow" class="external text" href="http://search.cpan.org/perldoc?Test::Nginx">Test::Nginx documentation</a> for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: <a rel="nofollow" class="external free" href="http://qa.openresty.org">http://qa.openresty.org</a>.
</p>

<p>This module is licensed under the BSD license.
</p><p>Copyright (C) 2009-2013, by Xiaozhe Wang (chaoslawful) &lt;chaoslawful@gmail.com&gt;.
</p><p>Copyright (C) 2009-2013, by Yichun "agentzh" Zhang () &lt;agentzh@gmail.com&gt;, CloudFlare Inc.
</p>









</div>
            


	    
	    
	  </div>
	</div>

      </div> 


    





</body></html>